
.libPaths("/home/metafun/miniforge3/envs/R_heatmap/lib/R/library")

#detach("package:Biostrings", unload = TRUE)
library(rhdf5)
#source("gene_tree.R", local = TRUE)

# app.R
#new

library(shinyjs)
library(shinythemes)
library(shiny)
library(ComplexHeatmap)
library(InteractiveComplexHeatmap)
library(circlize)
library(ggplot2)
library(dplyr)
library(tidyr)
library(stringr)
library(RColorBrewer)
library(ragg)
library(DT)
library(shinyWidgets)
library(shinydashboard)

library(ape)

library(ggtree)
library(Biostrings)
library(phytools)

library(geiger)
library(plotly)
library(htmlwidgets)



# CARD heatmap 생성 함수
create_card_heatmap <- function(input_csv, metadata_file, meta_col_selected) {

    # args <- commandArgs(trailingOnly = TRUE)

    # if (length(args) == 0) {
    #     cat("No arguments provided. Exiting script.\n -i : Input is rgi result generated by add_rgi_togenePA.py, -m metadata CSV file, -out output heatmap file, -meta_cols : metadata column numbers like 2,3,4\n")
    # quit(save = "no", status = 1)
    # }

    # arg_list <- list()
    # for (i in seq(1, length(args), 2)) {
    # arg_list[[args[i]]] <- args[i + 1]
    # }

    # input_csv <- arg_list[["-i"]]
    # metadata_file <- arg_list[["-m"]]
    # output_file <- arg_list[["-out"]]
    # meta_col_selected <- arg_list[["-mc"]]
    # meta_col_selected <- as.integer(meta_col_selected)
    # meta_cols <- NULL

    # output_html <- arg_list[["-out_html"]]

    set_font <- function() {
    par(family = "Helvetica")
    }

    set_font()

    # if ("-meta_cols" %in% names(arg_list)) {
    #     meta_cols <- unlist(strsplit(arg_list[["-meta_cols"]], ","))
    # }

    # prohibit too long legend text. 
    wrap_after_two_semicolons <- function(s) {
    parts <- unlist(strsplit(s, split = ";", fixed = TRUE))
    new_text <- ""
    for (i in seq_along(parts)) {
        new_text <- paste(new_text, parts[i], sep = "")
        if (i < length(parts) && (i %% 2 == 0)) {
        new_text <- paste(new_text, ";", "\n", sep = "")
        } else if (i < length(parts)) {
        new_text <- paste(new_text, ";", sep = "")
        }
    }
    new_text
    }

    wrap_after_semicolon <- function(s) {
    parts <- unlist(strsplit(s, split = ";", fixed = TRUE))
    new_text <- paste(parts, collapse = ";\n")
    new_text
    }

    clean_column_names <- function(df) {
    names(df) <- gsub(" ", "_", names(df))
    return(df)
    }

    card_raw <- read.csv(input_csv, header = TRUE,check.names=FALSE)

    card_raw <- clean_column_names(card_raw)

    #input should be csv. 
    metadata <- read.csv(metadata_file, header = TRUE, check.names = FALSE)

    selected_colname = colnames(metadata)[meta_col_selected]

    data <- read.csv(input_csv, header = TRUE, check.names = FALSE)
    # if (!is.null(meta_cols)) {
    #     meta_cols <- as.numeric(meta_cols)
    #     metadata <- metadata[, meta_cols, drop = FALSE]
    # }

    rownames(metadata) <- metadata[,1] # should revise automated metadata , the uniform metadata would be utilized I guess 
    # free below line 
    # rownames(metadata) <- metadata[,colnaems(metadata[,])]


    card_heatmap_data <- card_raw[, 2:(ncol(card_raw) - 3)]


    selected_columns <- c("Completeness", "Contamination", "classification", colnames(metadata[selected_colname])) #meta1380 %>% select(ncol(.)))
    meta_filtered_forvis <- metadata[, selected_columns]
    meta_filtered_forvis <- meta_filtered_forvis %>%
    mutate(!!selected_colname := replace(.[[selected_colname]], .[[selected_colname]] == "", "NA"))

    classification_split <- strsplit(as.character(meta_filtered_forvis$classification), ";")
    classification_df <- do.call(rbind, classification_split)
    colnames(classification_df) <- c("Domain", "Phylum", "Class", "Order", "Family", "Genus", "Species")
    classification_df <- as.data.frame(classification_df)
    meta_filtered_forvis <- cbind(meta_filtered_forvis[, -which(colnames(meta_filtered_forvis) == "classification")], classification_df)

    meta_filtered_forvis_ordered <- meta_filtered_forvis[match(colnames(card_heatmap_data), rownames(meta_filtered_forvis)),]

    top_annotation <- HeatmapAnnotation(df = meta_filtered_forvis_ordered,
                                        annotation_name_gp = gpar(fontsize = 7))


    basic_metadata <- meta_filtered_forvis_ordered[, !colnames(meta_filtered_forvis_ordered) %in% c(selected_colname,"Domain", "Phylum", "Class", "Order", "Family")]
    user_metadata <- meta_filtered_forvis_ordered[, selected_colname, drop = FALSE]

    top_annotation_boxplot <- HeatmapAnnotation(Average_value = anno_boxplot(as.matrix(card_heatmap_data), axis = TRUE,height = unit(1.0, "cm"),
                                axis_param = list(labels_rot = 0)),
    annotation_name_side = "left", annotation_name_rot = 0,
    annotation_name_gp = gpar(fontsize = 11, fontfamily = "Helvetica",fontface="bold")#,
    #height = unit(1.0, "cm")
    )
    top_annotation_basic <- HeatmapAnnotation(
    df = basic_metadata,
    annotation_name_side = "left",
    annotation_name_gp = gpar(fontsize = 11, fontfamily = "Helvetica",fontface="bold"),
    annotation_legend_param = list(
    title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface = "bold"),
    labels_gp = gpar(fontsize = 11, fontfamily = "Helvetica")
    )
    )
    top_annotation_user <- HeatmapAnnotation(
    df = user_metadata,
    annotation_name_side = "left",
    annotation_name_gp = gpar(fontsize = 11, fontfamily = "Helvetica", col = "red", fontface="bold"),
        annotation_legend_param = list(
        title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface = "bold"),
        labels_gp = gpar(fontsize = 11, fontfamily = "Helvetica")
    )
    )

    pdf_width <- (2.5*ncol(card_heatmap_data) +90 + 110 +100 +40) / 25.4
    pdf_height <- (2.5*nrow(card_heatmap_data) + 45 +40 + 40 ) / 25.4

    if (pdf_width >= 20.9) {
    pdf_width <- 20.9
    }

    if (pdf_height >= 15) {
    pdf_height <- 15.65
    }

    arg_info <- card_raw[, (ncol(card_raw) - 2):ncol(card_raw)]

print("arg_info")
print(arg_info)

    rowsum_data <- data.frame(rowsum = rowSums(card_heatmap_data))

    # ############
    # reorder based on largest category
    integrated_data <- cbind(card_heatmap_data, arg_info) %>%
    mutate(rowsum = rowSums(select(., 1:(ncol(card_heatmap_data)))))

    integrated_data_sorted <- integrated_data %>%
    group_by(Resistance_Mechanism) %>%
    arrange(Resistance_Mechanism, desc(rowsum)) %>%
    mutate(row_index = row_number()) %>%
    ungroup() %>%
    arrange(Resistance_Mechanism, row_index)

    row_order <- integrated_data_sorted$row_index

    if(n_distinct(integrated_data_sorted$CARD_Short_Name) > 90) {
    top_90_card <- integrated_data_sorted %>%
        group_by(CARD_Short_Name) %>%
        summarise(total_rowsum = sum(rowsum)) %>%
        arrange(desc(total_rowsum)) %>%
        slice_head(n = 90) %>%
        pull(CARD_Short_Name)
    
    integrated_data_sorted <- integrated_data_sorted %>%
        mutate(CARD_Short_Name_display = ifelse(CARD_Short_Name %in% top_90_card, CARD_Short_Name, "Other"))
    } else {
    integrated_data_sorted$CARD_Short_Name_display <- integrated_data_sorted$CARD_Short_Name
    }


    integrated_matrix <- as.matrix(integrated_data_sorted[, 1:ncol(card_heatmap_data)])

    split_data <- split(as.data.frame(t(integrated_matrix)), meta_filtered_forvis_ordered[, selected_colname])
    split_matrix <- do.call(cbind, lapply(split_data, function(x) colMeans(x, na.rm = TRUE)))

    print(paste("Dimensions of card_heatmap_data:", paste(dim(card_heatmap_data), collapse = " x ")))
    print(paste("Dimensions of split_matrix:", paste(dim(split_matrix), collapse = " x ")))

    distribution_colors <- scales::hue_pal()(ncol(split_matrix))
    distribution_legend <- Legend(
        labels = colnames(split_matrix),
        legend_gp = gpar(fill = distribution_colors),
        title = "Resistance_averages",
        title_gp = gpar(fontsize = 12, fontfamily = "Helvetica",fontface="bold"),
        labels_gp = gpar(fontsize = 11, fontfamily = "Helvetica")    
    )

    left_annotation <- rowAnnotation(
    Resistance_averages = anno_points(
        split_matrix,
        pch = 1:ncol(split_matrix),
        size = unit(1, "mm"),
        title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface = "bold"),
        gp = gpar(col = scales::hue_pal()(ncol(split_matrix))),
        width = unit(3, "cm")
    ),
    annotation_name_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface = "bold")
    )


    integrated_data_sorted$Resistance_Mechanism <- sapply(integrated_data_sorted$Resistance_Mechanism, wrap_after_semicolon)

    #arg_info$"Drug_Class" <- sapply(arg_info$"Drug_Class", wrap_after_two_semicolons)

    head(integrated_data)

#  reorder  based on heatmap order 
resistance_mechanism_order <- unique(integrated_data_sorted$Resistance_Mechanism)
drug_class_order <- unique(integrated_data_sorted$Drug_Class)
card_short_name_order <- unique(integrated_data_sorted$CARD_Short_Name)

    # row_annotation <- HeatmapAnnotation(
    # Resistance_Mechanism = integrated_data_sorted$Resistance_Mechanism,
    # CARD_Short_Name = integrated_data_sorted$CARD_Short_Name_display,
    # which = 'row',
    # annotation_name_gp = gpar(fontsize = 11, fontfamily = "Helvetica", fontface = "bold"),
    # annotation_legend_param = list(
    #     title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface = "bold"),
    #     labels_gp = gpar(fontsize = 11, fontfamily = "Helvetica")
    # )
    # )

    # row_annotation_hover <- HeatmapAnnotation(
    # Drug_Class = integrated_data_sorted$Drug_Class,
    # show_annotation_name = TRUE,
    # show_legend = FALSE,
    # which = 'row'
    # )

    row_annotation <- HeatmapAnnotation(
  Resistance_Mechanism = integrated_data_sorted$Resistance_Mechanism,
  CARD_Short_Name = integrated_data_sorted$CARD_Short_Name_display,
  which = 'row',
  annotation_name_gp = gpar(fontsize = 11, fontfamily = "Helvetica", fontface = "bold"),
  annotation_legend_param = list(
    Resistance_Mechanism = list(
      title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface = "bold"),
      labels_gp = gpar(fontsize = 11, fontfamily = "Helvetica"),
      at = resistance_mechanism_order,
      labels = resistance_mechanism_order
    ),
    CARD_Short_Name = list(
      title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface = "bold"),
      labels_gp = gpar(fontsize = 11, fontfamily = "Helvetica"),
      at = card_short_name_order,
      labels = card_short_name_order
    )
  )
)

row_annotation_hover <- HeatmapAnnotation(
  Drug_Class = integrated_data_sorted$Drug_Class,
  show_annotation_name = TRUE,
  show_legend = FALSE,
  which = 'row'
)

row_annotation <- HeatmapAnnotation(
  Resistance_Mechanism = integrated_data_sorted$Resistance_Mechanism,
  Drug_Class = integrated_data_sorted$Drug_Class,
  CARD_Short_Name = integrated_data_sorted$CARD_Short_Name_display,
  which = 'row',
  annotation_name_gp = gpar(fontsize = 11, fontfamily = "Helvetica", fontface = "bold"),
  annotation_legend_param = list(
    Resistance_Mechanism = list(
      title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface = "bold"),
      labels_gp = gpar(fontsize = 11, fontfamily = "Helvetica"),
      at = resistance_mechanism_order,
      labels = resistance_mechanism_order
    ),
    Drug_Class = list(
      title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface = "bold"),
      labels_gp = gpar(fontsize = 11, fontfamily = "Helvetica"),
      at = drug_class_order,
      labels = drug_class_order
    ),
    CARD_Short_Name = list(
      title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface = "bold"),
      labels_gp = gpar(fontsize = 11, fontfamily = "Helvetica"),
      at = card_short_name_order,
      labels = card_short_name_order
    )
  ),
  show_legend = c(Resistance_Mechanism = TRUE, Drug_Class = FALSE, CARD_Short_Name = TRUE)
)



    message("which")
    head(row_annotation)

    length(unique(as.vector(card_heatmap_data)))



    process_card_heatmap_data <- function(card_heatmap_data) {
    if (max(card_heatmap_data) <= 1) {
        # Presence/Absence case
        return(list(
        color_function = colorRamp2(c(0, 1), c("lightgrey", "red")),
        legend_labels = c("Absent", "Present"),
        at = c(0, 1)
        ))
    } else {
        # Gene count case
        breaks <- c(0, min(card_heatmap_data[card_heatmap_data > 0]), max(card_heatmap_data))
        colors <- c("lightgrey", "white", "red")
        return(list(
        color_function = colorRamp2(breaks, colors),
        legend_labels = as.character(breaks),
        at = breaks
        ))
      }
    }

    print(card_heatmap_data[1:3,1:3])
    print(card_heatmap_data[(nrow(card_heatmap_data)-3):nrow(card_heatmap_data),(ncol(card_heatmap_data)-3):ncol(card_heatmap_data)])

    result <- process_card_heatmap_data(card_heatmap_data)
    my_color_function <- result$color_function
    legend_labels <- result$legend_labels
    legend_at <- result$at


    ht1 <- Heatmap(
        as.matrix(integrated_data_sorted[, 1:ncol(card_heatmap_data)]),
        #as.matrix(card_heatmap_data),
        name = "Antimicrobial resistance\n gene number",
        col = my_color_function,

        top_annotation = c(top_annotation_boxplot, top_annotation_basic, top_annotation_user),
        right_annotation = c(row_annotation, row_annotation_hover),
        #row_order = order(as.integer(factor(grouped_data$Resistance_Mechanism)), grouped_data$row_index),
        row_order = order(as.integer(factor(integrated_data_sorted$Resistance_Mechanism)), integrated_data_sorted$row_index),
        left_annotation=left_annotation,
        heatmap_legend_param = list(
        legend_direction = "horizontal",
        title_gp = gpar(fontsize = 12, fontfamily = "Helvetica",fontface="bold"),
        labels_gp = gpar(fontsize = 11, fontfamily = "Helvetica"),
        labels = legend_labels,
        at = legend_at
        ), 
        show_row_names = FALSE,
        show_column_names = FALSE,
        show_column_dend = FALSE,
        show_row_dend = FALSE,
        column_split  = meta_filtered_forvis_ordered[,selected_colname],
        row_names_gp = gpar(fontsize = 11, fontfamily = "Helvetica"),
        column_names_gp = gpar(fontsize = 11, fontfamily = "Helvetica"),
        column_title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface = "bold", col = "blue")
    )

    ht1 <- draw(ht1,
    padding = unit(c(2, 2, 2, 2), "cm"),
    annotation_legend_list = list(distribution_legend),annotation_legend_side = "left")

    message("CARD draw heatmap is complete")

    return(list(
      plot=ht1,
      data = integrated_data_sorted,
    gene_info = card_raw[, c("Gene", "CARD_Short_Name", "Resistance_Mechanism", "Drug_Class")]
    ))
    #htShiny(ht1, output_ui_float = TRUE, save = output_html)
    
}

# dbCAN heatmap 생성 함수
#create_dbcan_heatmap
  create_dbcan_heatmap <- function(input_csv, gene_count_csv, metadata_file, meta_col_selected) {


    set_font <- function() {
    par(family = "Helvetica")
    }
    set_font()

    # prohibit too long legend text. 
    wrap_after_two_semicolons <- function(s) {
    parts <- unlist(strsplit(s, split = ";", fixed = TRUE))
    new_text <- ""
    for (i in seq_along(parts)) {
        new_text <- paste(new_text, parts[i], sep = "")
        if (i < length(parts) && (i %% 2 == 0)) {
        new_text <- paste(new_text, ";", "\n", sep = "")
        } else if (i < length(parts)) {
        new_text <- paste(new_text, ";", sep = "")
        }
    }
    new_text
    }

    clean_column_names <- function(df) {
    names(df) <- gsub(" ", "_", names(df))
    return(df)
    }

    dbcan_raw <- read.csv(input_csv, header = TRUE,check.names=FALSE)
    dbcan_raw<- clean_column_names(dbcan_raw)

    #input should be csv. 
    metadata <- read.csv(metadata_file, header = TRUE, check.names = FALSE)
    selected_colname = colnames(metadata)[meta_col_selected]

#############
# newly added 
  gene_count_data <- read.csv(gene_count_csv, header = TRUE, check.names = FALSE)
  #print(head(gene_count_data))

gene_count_data <- gene_count_data %>%
    dplyr::mutate(HMMER = stringr::str_replace(HMMER, "\\(.*\\)", "")) %>%
    dplyr::mutate(HMMER = stringr::str_trim(HMMER)) %>%
    dplyr::mutate(
    HMMER_prefix = stringr::str_extract(HMMER, "^[A-Z]+"),
    HMMER_number = as.numeric(stringr::str_extract(HMMER, "[0-9]+$"))
    ) %>%
    dplyr::arrange(HMMER_prefix, HMMER_number) %>%
    dplyr::select(-HMMER_prefix, -HMMER_number)
    print("so far so good1")



# newly added 
#############

    #data <- read.csv(input_csv, header = TRUE, check.names = FALSE)
    # if (!is.null(meta_cols)) {
    #     meta_cols <- as.numeric(meta_cols)
    #     metadata <- metadata[, meta_cols, drop = FALSE]
    # }

    rownames(metadata) <- metadata[,1] # should revise automated metadata  

    sort_labels <- function(df, label_col) {
    df %>%
        mutate(
        Prefix = str_extract(!!sym(label_col), "^[A-Z]+"),
        Number = as.numeric(str_extract(!!sym(label_col), "[0-9]+$")),
        Prefix_Order = match(Prefix, c("AA", "CBM", "CE", "GH", "GT", "PL")) # Set custom order of prefixes
        ) %>%
        arrange(Prefix_Order, Number) %>%
        select(-c(Prefix, Number, Prefix_Order))
    }


    dbcan_raw <- sort_labels(dbcan_raw,"HMMER")

    head(dbcan_raw)
    dbcan_raw <- dbcan_raw %>% 
    mutate(Prefix = str_extract(!!sym("HMMER"), "^[A-Z]+"))
    dbcan_heatmap_data<- dbcan_raw[,2:(ncol(dbcan_raw)-1)]

    selected_columns <- c("Completeness", "Contamination", "classification", colnames(metadata[selected_colname])) #meta1380 %>% select(ncol(.)))
    meta_filtered_forvis <- metadata[, selected_columns]
    meta_filtered_forvis <- meta_filtered_forvis %>%
    mutate(!!selected_colname := replace(.[[selected_colname]], .[[selected_colname]] == "", "NA"))

    classification_split <- strsplit(as.character(meta_filtered_forvis$classification), ";")
    classification_df <- do.call(rbind, classification_split)
    colnames(classification_df) <- c("Domain", "Phylum", "Class", "Order", "Family", "Genus", "Species")
    classification_df <- as.data.frame(classification_df)
    meta_filtered_forvis <- cbind(meta_filtered_forvis[, -which(colnames(meta_filtered_forvis) == "classification")], classification_df)

    meta_filtered_forvis_ordered <- meta_filtered_forvis[match(colnames(dbcan_heatmap_data), rownames(meta_filtered_forvis)),]

    # top_annotation <- HeatmapAnnotation(df = meta_filtered_forvis_ordered,
    #                                     annotation_name_gp = gpar(fontsize = 7))

    basic_metadata <- meta_filtered_forvis_ordered[, !colnames(meta_filtered_forvis_ordered) %in% c(selected_colname,"Domain", "Phylum", "Class", "Order", "Family")]
    user_metadata <- meta_filtered_forvis_ordered[, selected_colname, drop = FALSE]

    top_annotation_boxplot <- HeatmapAnnotation(
      Average_value = anno_boxplot(as.matrix(dbcan_heatmap_data), axis = TRUE, height = unit(1.0, "cm"),
                                axis_param = list(labels_rot = 0)),
    annotation_name_side = "left", annotation_name_rot = 0,
    annotation_name_gp = gpar(fontsize = 11, fontfamily = "Helvetica", fontface="bold")
    )

    top_annotation_basic <- HeatmapAnnotation(
    df = basic_metadata,
    annotation_name_side = "left",
    annotation_name_gp = gpar(fontsize = 11, fontfamily = "Helvetica", fontface="bold"),
    annotation_legend_param = list(
        title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface = "bold"),
        labels_gp = gpar(fontsize = 11, fontfamily = "Helvetica")
    )
    )

    top_annotation_user <- HeatmapAnnotation(
    df = user_metadata,
    annotation_name_side = "left",
    annotation_name_gp = gpar(fontsize = 11, fontfamily = "Helvetica", col = "red", fontface="bold"),
    annotation_legend_param = list(
        title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface = "bold"),
        labels_gp = gpar(fontsize = 11, fontfamily = "Helvetica")
    )
    )

    integrated_data <- cbind(dbcan_heatmap_data, dbcan_raw[, c("Prefix", "HMMER")]) %>%
    mutate(rowsum = rowSums(select(., 1:(ncol(dbcan_heatmap_data)))))

    integrated_data_sorted <- integrated_data %>%
    group_by(Prefix) %>%
    arrange(Prefix, desc(rowsum)) %>%
    mutate(row_index = row_number()) %>%
    ungroup() %>%
    arrange(Prefix, row_index)
       print("so far so good6")

    row_order <- order(integrated_data_sorted$Prefix, integrated_data_sorted$row_index)

    #row_order <- integrated_data_sorted$row_index
    split_data <- split(as.data.frame(t(integrated_data_sorted[, 1:ncol(dbcan_heatmap_data)])), meta_filtered_forvis_ordered[, selected_colname])
    split_matrix <- do.call(cbind, lapply(split_data, function(x) colMeans(x, na.rm = TRUE)))

    distribution_colors <- scales::hue_pal()(ncol(split_matrix))
    distribution_legend <- Legend(
        labels = colnames(split_matrix),
        legend_gp = gpar(fill = distribution_colors),
        title = "CAZyme_averages",
        title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface="bold"),
        labels_gp = gpar(fontsize = 11, fontfamily = "Helvetica")    
    )

    left_annotation <- rowAnnotation(
    CAZyme_averages = anno_points(
        split_matrix,
        pch = 1:ncol(split_matrix),
        size = unit(1, "mm"),
        title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface = "bold"),
        gp = gpar(col = scales::hue_pal()(ncol(split_matrix))),
        width = unit(3, "cm")
    ),
    annotation_name_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface = "bold")
    )

    caz_info <- integrated_data_sorted[, c("Prefix", "HMMER")]
    names(caz_info) <- c("CAZymes family", "CAZymes subfamily")

    row_annotation <- HeatmapAnnotation(df = caz_info, which='row',
                                                                        show_legend = c("CAZymes family" = TRUE, "CAZymes subfamily" = FALSE),
    annotation_name_gp = gpar(fontsize = 11, fontfamily = "Helvetica", fontface = "bold"),
    annotation_legend_param = list(
        title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface = "bold"),
        labels_gp = gpar(fontsize = 11, fontfamily = "Helvetica")
    )
    )
    message("which")
    head(row_annotation)

    length(unique(as.vector(dbcan_heatmap_data)))

    breaks <- c(0, min(dbcan_heatmap_data[dbcan_heatmap_data>0]), max(dbcan_heatmap_data))
    colors <- c("lightgrey", "white", "#22d62b")

    if (length(unique(as.vector(dbcan_heatmap_data))) == 1) {
    my_color_function <- "#22d62b"
    } else {
    my_color_function <- colorRamp2(breaks,colors)
    }

    ht1 <- Heatmap(
        as.matrix(integrated_data_sorted[, 1:ncol(dbcan_heatmap_data)]),
        name = "Carbohydrate-active enzymes",
        col = my_color_function,
        row_labels = integrated_data_sorted$HMMER,  

        top_annotation = c(top_annotation_boxplot, top_annotation_basic, top_annotation_user),
        right_annotation = row_annotation,
        left_annotation = left_annotation,
        show_row_names = FALSE,
        show_column_names = FALSE,
        show_column_dend = FALSE,
        show_row_dend = FALSE,
        cluster_rows = FALSE,
        column_split  = meta_filtered_forvis_ordered[,selected_colname],
        heatmap_legend_param = list(
            legend_direction = "horizontal",
            title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface="bold"),
            labels_gp = gpar(fontsize = 11, fontfamily = "Helvetica")
        ),
        row_names_gp = gpar(fontsize = 11, fontfamily = "Helvetica"),
        column_names_gp = gpar(fontsize = 11, fontfamily = "Helvetica"),
        column_title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface = "bold", col = "blue")
    )

    pdf_width <- (2.5*ncol(dbcan_heatmap_data) + 90 + 110 + 40) / 25.4
    pdf_height <- (2.5*nrow(dbcan_heatmap_data) + 45 + 40 + 40) / 25.4
    if (pdf_width >= 20.9) {pdf_width = 20.9}
    if (pdf_height >= 15) {pdf_height = 15.65}

    #output_file <- "heatmap_dbCAN.pdf"
    ht1 <- draw(ht1,
    padding = unit(c(2, 2, 2, 2), "cm"),
    annotation_legend_list = list(distribution_legend),
    annotation_legend_side = "left"
    )
#    htShiny(ht, output_ui_float = TRUE, save = output_html)
   return(list(
    plot = ht1,
       data = integrated_data_sorted,
       gene_data = gene_count_data)
   # return(list(plot = ht1, data = integrated_data_sorted[, 1:ncol(dbcan_heatmap_data)]))
   )
}

#create_dbcan_heatmap
# dbCAN heatmap 생성 함수
# ANI heatmap
#create_ani_heatmap
create_ani_heatmap <- function(input_csv, metadata_file, meta_col_selected) {
  # ANI 데이터 읽기
library(shiny)
library(ComplexHeatmap)
library(circlize)
library(ggplot2)
library(dplyr)
library(tidyr)
library(stringr)
library(RColorBrewer)
library(InteractiveComplexHeatmap)
library(ragg)

   set_font <- function() {
    par(family = "Helvetica")
  }
  set_font()
  
  # 데이터 읽기
  skani_raw <- read.csv(input_csv, header=FALSE, sep='\t', check.names = FALSE)
  rownames(skani_raw) <- skani_raw[,1]
  skani_raw <- skani_raw[,-1]
  
  # 메타데이터 읽기
  metadata <- read.csv(metadata_file, header = TRUE, check.names = FALSE)
  
  # 메타데이터 열 선택
  selected_colname <- colnames(metadata)[meta_col_selected]
  
  # 메타데이터 처리
  rownames(metadata) <- metadata[,1]
  selected_columns <- c("Completeness", "Contamination", "classification", colnames(metadata[selected_colname])) 
  meta_filtered_forvis <- metadata[, selected_columns]
  meta_filtered_forvis <- meta_filtered_forvis %>%
    mutate(!!selected_colname := replace(.[[selected_colname]], .[[selected_colname]] == "", "NA"))
  
  classification_split <- strsplit(as.character(meta_filtered_forvis$classification), ";")
  classification_df <- do.call(rbind, classification_split)
  colnames(classification_df) <- c("Domain", "Phylum", "Class", "Order", "Family", "Genus", "Species")
  classification_df <- as.data.frame(classification_df)
  
  meta_filtered_forvis <- meta_filtered_forvis[, !colnames(meta_filtered_forvis) %in% c("classification","Domain", "Phylum", "Class", "Order", "Family")]
  
  meta_filtered_forvis_ordered <- meta_filtered_forvis[match(rownames(skani_raw), rownames(meta_filtered_forvis)),]
  
  # 상단 주석 생성
  top_annotation <- HeatmapAnnotation(df = meta_filtered_forvis_ordered,
    annotation_name_gp = gpar(fontsize = 11, fontfamily = "Helvetica",  fontface="bold"),
    annotation_legend_param = list(
      title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface = "bold"),
      labels_gp = gpar(fontsize = 11, fontfamily = "Helvetica")
    )
  )


  # 색상 설정
 breaks <- c(80, 80.000001, 100)
  colors <- c("lightgrey", "white", "red")
  my_color_function <- colorRamp2(breaks, colors)

  #breaks <- c(0, min(skani_raw[skani_raw > 0]), max(skani_raw))
  #colors <- c("lightgrey", "white", "red")
  #my_color_function <- if (length(unique(as.vector(skani_raw))) == 1) "red" else colorRamp2(breaks, colors)
  
  # 히트맵 생성
  ht <- Heatmap(
    as.matrix(skani_raw),
    name = "ANI values inferred using skani",
    col = my_color_function,
    top_annotation = top_annotation,
    show_row_names = FALSE,
    show_column_names = FALSE,
    heatmap_legend_param = list(
      at = c(80, 90, 100),
      labels = c("80%", "90%", "100%"),        
      title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface = "bold"),
      labels_gp = gpar(fontsize = 11, fontfamily = "Helvetica")
    ),
    row_names_gp = gpar(fontsize = 11, fontfamily = "Helvetica"),
    column_names_gp = gpar(fontsize = 11, fontfamily = "Helvetica")
  )
  
  return(ht)
}








# KEGG heatmap 생성 함수
# KEGG heatmap 생성 함수
#create_kegg_heatmap <- function(input_kegg_matrix, metadata_file, meta_col_selected, module_completeness_threshold) {
create_kegg_heatmap <- function(input_kegg_matrix, metadata_file, meta_col_selected, module_completeness_threshold, cpu_count) {

    library(ComplexHeatmap)
    library(circlize)
    library(ggplot2)
    library(dplyr)
    library(tidyr)
    library(stringr)
    library(RColorBrewer)
    library(circlize)
    library(InteractiveComplexHeatmap)
    library(shiny)
    library(DT)
    library(htmlwidgets)
    #  parse command line arguments
    #args <- commandArgs(trailingOnly = TRUE)

    set_font <- function() {
    par(family = "Helvetica")
    }

    set_font()


    metadata <- read.csv(metadata_file, header = TRUE, check.names = FALSE)
    # default KEGG module threshold is 50%. 
    #module_completeness_threshold <- 0.5

    selected_colname = colnames(metadata)[meta_col_selected]

    # if (!is.numeric(module_completeness_threshold) || module_completeness_threshold < 0 || module_completeness_threshold > 1) {
    #     warning("Invalid module completeness threshold provided. Using default value of 0.5 (50%).")
    #     module_completeness_threshold <- 0.5
    # }
    

    library(ggkegg)
    library(ggfx)
    library(tidygraph)
    library(dplyr)
    library(tidyr)
    library(parallel)

    # Read the input files

    KOtable <- read.csv(input_kegg_matrix, header = TRUE,check.names =FALSE)
    KOtable <- KOtable[,-1]


    ko_long_format <-  KOtable %>%
    pivot_longer(cols = everything(), names_to = "Genome", values_to = "KOs")
    unique(ko_long_format$Genome)


    mapper <- data.table::fread("KEGG/mapper.tsv", header=TRUE)
    allmods <-  gsub("md:", "", mapper$V1) %>%  unique()


    # modules downloaded in 2023 Dec 20 
    mf <-  list.files("KEGG/KEGG_modules")
    mf <- mf[startsWith(mf, "M")]
    annos <- list()

    library(parallel)
#    cl <- makeCluster(detectCores() - 1)
  cl <- parallel::makeCluster(cpu_count)

    clusterEvalQ(cl, {
    library(ggkegg)
    library(ggfx)
    library(tidygraph)
    library(dplyr)
    library(tidyr)
    })
    print("It's KOtable")
    print(head(KOtable))
    print(exists("KOtable"))
    print("it's cluster")
    calculate_completeness <-  function(genome) {
          print(paste("Processing genome:", genome))
          print(paste("KOtable exists:", exists("KOtable")))
    kos <- KOtable[[genome]][!is.na(KOtable[[genome]])]
    mcs <- sapply(mf, function(mod) {
        mc <- module_completeness(module(mod, directory="KEGG/KEGG_modules/"), 
                                query = kos)
        mean(mc$complete)
    })
    names(mcs) <- mf
    return(mcs)
    }
    print("it's cluster definition")
    parallel::clusterExport(cl, c("KOtable", "mf", "calculate_completeness"), envir = environment()) 
    print("it's cluster run")

    results <- parallel::parLapply(cl, colnames(KOtable), calculate_completeness)
    names(results) <- colnames(KOtable)
    stopCluster(cl)

    hdf <- data.frame(results,check.names=FALSE)

    row.names(hdf) <- mf
    hdf[is.na(hdf)] <- 0
    threshold <- 0.5
    hdf <- hdf[apply(hdf, 1, function(x) any(x >= module_completeness_threshold)), ]

    # module description and CLASS description third columns are most bigger concept 
    #moddesc <- data.table::fread("https://rest.kegg.jp/list/module", header=FALSE)
    #data.table::fwrite(module_desc,"module_desc.txt",col.names=TRUE)
    moddesc<- data.table::fread("KEGG/module_desc.txt", header=FALSE)

    mod_class <- read.csv("KEGG/KEGG_modules/modes_class_description.tsv",
            sep='\t',header=FALSE)
    #mod_class_name <- read.csv("KEGG/KEGG_modules/modes_class_Name_description.tsv",
    #         sep='\t',header=FALSE)


    merged_modedesc <- merge(moddesc, mod_class, by="V1")

    library(ragg)
    library(ComplexHeatmap)
    library(circlize)
    library(InteractiveComplexHeatmap)
    rownames(hdf)

    #generate ordered module table following CLASS
    merged_modedesc <- merged_modedesc %>%
    arrange(V2.y, V3, V2.x)
    module_order <- merged_modedesc$V1[merged_modedesc$V1 %in% rownames(hdf)]
    hdf <- hdf[module_order, ]
    annotation_reordered_modedesc <- merged_modedesc %>%
    filter(V1 %in% rownames(hdf)) %>%
    select(V2.x, V3,V2.y)


    library(tibble)
    ## new add, order 
    hdf <- hdf %>%
    rownames_to_column("Module") %>%
    left_join(merged_modedesc, by = c("Module" = "V1")) %>%
    mutate(rowsum = rowSums(select(., where(is.numeric)))) %>%
    group_by(V2.y) %>%
    arrange(V2.y, desc(rowsum)) %>%
    ungroup() %>%
    column_to_rownames("Module") %>%
    select(-rowsum, -V2.x, -V3, -V2.y)


    annotation_reordered_modedesc <- merged_modedesc %>%
    filter(V1 %in% rownames(hdf)) %>%
    mutate(rowsum = rowSums(select(hdf, where(is.numeric)))) %>%
    arrange(V2.y, desc(rowsum)) %>%
    select(V2.x, V3, V2.y)

    names(annotation_reordered_modedesc) <- c("Module_Name", "Pathway_Category", "Pathway_Class")

#  parsing according to  heatmap order 


    # ha_module <- rowAnnotation(df = annotation_reordered_modedesc[, c("Pathway_Category", "Pathway_Class")],
    #                         gp = gpar(fontsize = 11, fontfamily = "Helvetica"),  
    #                         annotation_name_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface = "bold"),
    #                         annotation_legend_param = list(
    #                             title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface = "bold"),
    #                             labels_gp = gpar(fontsize = 11, fontfamily = "Helvetica")
    #                         )
    # )
pathway_class_order <- unique(annotation_reordered_modedesc$Pathway_Class)
pathway_category_order <- unique(annotation_reordered_modedesc$Pathway_Category)


ha_module <- rowAnnotation(
  Pathway_Class = annotation_reordered_modedesc$Pathway_Class,
  Pathway_Category = annotation_reordered_modedesc$Pathway_Category,
  gp = gpar(fontsize = 11, fontfamily = "Helvetica"),  
  annotation_name_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface = "bold"),
  annotation_legend_param = list(
    Pathway_Class = list(
      title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface = "bold"),
      labels_gp = gpar(fontsize = 11, fontfamily = "Helvetica"),
      at = pathway_class_order,
      labels = pathway_class_order
    ),
    Pathway_Category = list(
      title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface = "bold"),
      labels_gp = gpar(fontsize = 11, fontfamily = "Helvetica"),
      at = pathway_category_order,
      labels = pathway_category_order
    )
  )
)



    rownames(metadata) <- metadata[,1]
    selected_columns <- c("Completeness", "Contamination", "classification", colnames(metadata[selected_colname]))
    meta_filtered_forvis <- metadata[, selected_columns]
    head(meta_filtered_forvis)
    meta_filtered_forvis <- meta_filtered_forvis %>%
    mutate(!!selected_colname := replace(.[[selected_colname]], .[[selected_colname]] == "", "NA"))

    classification_split <- strsplit(as.character(meta_filtered_forvis$classification), ";")
    classification_df <- do.call(rbind, classification_split)
    colnames(classification_df) <- c("Domain", "Phylum", "Class", "Order", "Family", "Genus", "Species")
    classification_df <- as.data.frame(classification_df)
    meta_filtered_forvis <- cbind(meta_filtered_forvis[, -which(colnames(meta_filtered_forvis) == "classification")], classification_df)
    meta_filtered_forvis_ordered <- meta_filtered_forvis[match(colnames(hdf), rownames(meta_filtered_forvis)),]


    #split selected one and basic metadata
    basic_metadata <- meta_filtered_forvis_ordered[, !colnames(meta_filtered_forvis_ordered) %in% c(selected_colname,"Domain", "Phylum", "Class", "Order", "Family")]
    user_metadata <- meta_filtered_forvis_ordered[, selected_colname, drop = FALSE]

    top_annotation_boxplot <- HeatmapAnnotation(Average_value = anno_boxplot(as.matrix(hdf), axis = TRUE,height = unit(1.0, "cm"),
                                axis_param = list(labels_rot = 0)),
    annotation_name_side = "left", annotation_name_rot = 0,
    annotation_name_gp = gpar(fontsize = 11, fontfamily = "Helvetica",fontface="bold")#,
    #height = unit(1.0, "cm")

    )

    top_annotation_basic <- HeatmapAnnotation(
    df = basic_metadata,
    annotation_name_side = "left",
    annotation_name_gp = gpar(fontsize = 11, fontfamily = "Helvetica",fontface="bold"),
    annotation_legend_param = list(
    title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface = "bold"),
    labels_gp = gpar(fontsize = 11, fontfamily = "Helvetica")
    ))


    top_annotation_user <- HeatmapAnnotation(
    df = user_metadata,
    annotation_name_side = "left",
    annotation_name_gp = gpar(fontsize = 11, fontfamily = "Helvetica", col = "red", fontface="bold"),
        annotation_legend_param = list(
        title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface = "bold"),
        labels_gp = gpar(fontsize = 11, fontfamily = "Helvetica")
    )
    )

    split_data <- split(as.data.frame(t(hdf)), meta_filtered_forvis_ordered[, selected_colname])
    split_matrix <- do.call(cbind, lapply(split_data, function(x) colMeans(x, na.rm = TRUE)))

    print(paste("Dimensions of hdf:", paste(dim(hdf), collapse = " x ")))
    print(paste("Dimensions of split_matrix:", paste(dim(split_matrix), collapse = " x ")))

    distribution_colors <- scales::hue_pal()(ncol(split_matrix))
    distribution_legend <- Legend(
        labels = colnames(split_matrix),
        legend_gp = gpar(fill = distribution_colors),
        title = "Module_averages",
        title_gp = gpar(fontsize = 12, fontfamily = "Helvetica",fontface="bold"),
        labels_gp = gpar(fontsize = 11, fontfamily = "Helvetica")    
    )

    print(paste("Number of groups after split:", length(split_data)))
    print(paste("Dimensions of split_matrix:", paste(dim(split_matrix), collapse = " x ")))
    print(paste("Dimensions of hdf:", paste(dim(hdf), collapse = " x ")))
    #head(hdf)
    #print(split_matrix)


    if (nrow(split_matrix) != nrow(hdf)) {
    stop("Mismatch in dimensions between split_matrix and hdf.")
    }

    # left annotation , average module value in each  group of genomes 
    left_annotation <- rowAnnotation(
    Module_averages = anno_points(split_matrix, 
                                pch = 1:ncol(split_matrix),
                                size = unit(1, "mm"),
                                title_gp = gpar(fontsize = 12, fontfamily = "Helvetica",fontface="bold"),

                                gp = gpar(col = scales::hue_pal()(ncol(split_matrix))),
                                width = unit(3, "cm")
    ),  annotation_name_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface="bold")
    )


#    col_fun <- colorRamp2(c(0, module_completeness_threshold -0.0000001 ,module_completeness_threshold, 1), c("black","black", "white", scales::muted("red")))
    if (module_completeness_threshold == 0) {
  col_fun <- colorRamp2(c(0, 1), c("white", scales::muted("red")))
} else {
  col_fun <- colorRamp2(c(0, module_completeness_threshold - 0.0000001, module_completeness_threshold, 1), 
                        c("black", "black", "white", scales::muted("red")))
}


    
    head(hdf)

    margin <- 20 
    # margin *2 + bottom top , marig*2 + left right
    pdf_width <- (2.5*ncol(hdf) +90 + 110 +  40) / 25.4
    pdf_height <- (2.5*nrow(hdf) + 45 +40 + 40 ) / 25.4

    # set maximum length
    if (pdf_width >= 20.9) {
    pdf_width = 20.9
    }
    if (pdf_height >= 15) {
    pdf_height = 15.65
    }

    #width = unit(4, "cm")

    ht1 <- Heatmap(as.matrix(hdf), show_column_names = FALSE,
                col = col_fun,
                right_annotation = ha_module,
                left_annotation=left_annotation,
    #               top_annotation = top_annotation,
                top_annotation = c(top_annotation_boxplot,top_annotation_basic, top_annotation_user),
                show_column_dend = FALSE,
                cluster_rows = FALSE,
                heatmap_legend_param = list(
                    legend_direction = "horizontal",
                    title_gp = gpar(fontsize = 12, fontfamily = "Helvetica",fontface="bold"),
                    labels_gp = gpar(fontsize = 11, fontfamily = "Helvetica")
                    ), 
                    name = "Module completeness",
                    border = TRUE,
                    column_split  = meta_filtered_forvis_ordered[,selected_colname],
                    row_names_gp = gpar(fontsize = 11, fontfamily = "Helvetica"),
                    column_names_gp = gpar(fontsize = 11, fontfamily = "Helvetica"),
                    column_title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface = "bold", col = "blue")  #set font of row title (metadata )
    )

    ht1 <- draw(ht1,
    padding = unit(c(2, 2, 2, 2), "cm"),
    annotation_legend_list = list(distribution_legend),annotation_legend_side = "left")
    
      ko_definition <- read.csv("KO_definition_GeneID_countgenomes.csv", header = TRUE, check.names = FALSE)
print("head hdf info : that is data")
      print(head(hdf))


    module_info_for_return <- data.frame(
        Module = rownames(hdf),
        Module_Name = annotation_reordered_modedesc$Module_Name,
        Pathway_Category = annotation_reordered_modedesc$Pathway_Category,
        Pathway_Class = annotation_reordered_modedesc$Pathway_Class
    )
    print("Head of module_info_for_return:")
    print(head(module_info_for_return))

    return(list(
        plot = ht1,
        data = hdf,
        module_info = module_info_for_return,
        ko_definition = ko_definition
    ))

    #return(ht1)

    # Save the interactive plot
     hover_info <- data.frame(
     Module = rownames(hdf),
     Name = annotation_reordered_modedesc$Module_Name,
     Category = annotation_reordered_modedesc$Pathway_Category,
     Class = annotation_reordered_modedesc$Pathway_Class
     )


######################################################

######################################################
# htShiny기존 코드 . 
#htShiny(ht1, output_ui_float = TRUE, save = output_html)
# Save the module completeness table
#write.csv(hdf, file = output_table)
}

# VFDB heatmap 생성 함수
create_vfdb_heatmap <- function(input_csv, metadata_file, meta_col_selected) {
    library(ComplexHeatmap)
    library(circlize)
    library(ggplot2)
    library(dplyr)
    library(tidyr)
    library(stringr)
    library(RColorBrewer)

    set_font <- function() {
    par(family = "Helvetica")
    }
    set_font()

    #args <- commandArgs(trailingOnly = TRUE
    # if (length(args) == 0) {
    #     cat("No arguments provided. Exiting script.\n -i : Input is CARD csv result generated by add_rgi_togenePA.py, -m metadata CSV file, -out output heatmap file, -meta_cols : metadata column numbers like 2,3,4\n")
    # quit(save = "no", status = 1)
    # }
    # arg_list <- list()
    # for (i in seq(1, length(args), 2)) {
    # arg_list[[args[i]]] <- args[i + 1]
    # }

    # input_csv <- arg_list[["-i"]]
    # metadata_file <- arg_list[["-m"]]
    # output_file <- arg_list[["-out"]]
    # meta_col_selected <- arg_list[["-mc"]]
    # meta_col_selected <- as.integer(meta_col_selected)
    # meta_cols <- NULL
    # output_html <- arg_list[["-out_html"]]

    # if ("-meta_cols" %in% names(arg_list)) {
    #     meta_cols <- unlist(strsplit(arg_list[["-meta_cols"]], ","))
    # }


    vfdb_raw <- read.csv(input_csv, header = TRUE, check.names = FALSE)
    metadata <- read.csv(metadata_file, header = TRUE, check.names = FALSE)
    selected_colname = colnames(metadata)[meta_col_selected]
    print(selected_colname)
    if (ncol(vfdb_raw) - 7 != nrow(metadata)) {
        stop("Mismatch in the number of columns in heatmap data and the number of rows in metadata.")
    }
    # for visualization partitioning
    # group_col_name <- colnames(metadata_file)[as.integer(meta_col_selected)]
    heatmap_data <- vfdb_raw[, 2:(ncol(vfdb_raw) - 6)]

    vf_info <- vfdb_raw[, (ncol(vfdb_raw) - 5):ncol(vfdb_raw)] # last 6 fields

#
#print(str(vfdb_raw$gene_name))
#print(head(vfdb_raw$gene_name))
    gene_vf_info <- vfdb_raw %>%
    dplyr::select(Gene,  VFG_ID, gene_description, VF_ID, VFC_ID, organism)


#
print("What's going on ?")
print(colnames(heatmap_data))
print(head(heatmap_data))

    heatmap_data_summarized <- heatmap_data %>% 
    mutate(VFID = vf_info$VF_ID) %>%
    group_by(VFID) %>%
    summarise_all(sum) #%>%
    #dplyr::rename(VFID = VF_ID)


print("heatmap_data_summarized")    
#print(str(heatmap_data_summarized))
print(names(heatmap_data_summarized))
#aka
print(colnames(vf_info))
head(vf_info)
print("What's going on ?2")
print("vf_info structure:")
print(str(vf_info))


# gene_name_temp <- vf_info$gene_name
#   print("What's going on ?3")

# vf_info_without_gene_name <- vf_info %>% select(-gene_name)
#   print("What's going on ?3")

# character_data <- vf_info_without_gene_name %>%
#   group_by(VF_ID) %>%
#   summarise_all(~first(.))

#   print("What's going on ?3")
# character_data$gene_name <- gene_name_temp[match(character_data$VF_ID, vf_info$VF_ID)]

#   print("What's going on ?4")



# vf_info <- vf_info %>%
#   rename(gene_name_str = gene_name)
  
#   gene_name <- NULL  # 기존의 gene_name 함수를 제거


# print("What's going on ?5")

# character_data <- vf_info %>%
#   dplyr::group_by(VF_ID) %>%
#   dplyr::summarise(
#     gene_name = first(as.character(gene_name)),
#     VFG_ID = first(as.character(VFG_ID)),
#     gene_description = first(as.character(gene_description)),
#     VFC_ID = first(as.character(VFC_ID)),
#     organism = first(as.character(organism))
#   )
#   print("What's going on ?6")

    
    character_data <- vf_info %>%
    dplyr::group_by(VF_ID) %>%
         dplyr::summarise_all(~ dplyr::first(.)) 
 print("What's going on ?5")

 
print("character_data structure:")
print(str(character_data))
print("heatmap_data_summarized structure before binding:")
print(str(heatmap_data_summarized))

    select_numeric_columns <- function(df) {
    df %>% select(where(is.numeric))
    }

    heatmap_data_summarized <- bind_cols(character_data, heatmap_data_summarized)
    heatmap_data_summarized <- heatmap_data_summarized %>%
    mutate(
        VFC = str_extract(VFC_ID, "VFC\\d+"),
        VF = str_extract(VF_ID, "VF\\d+")
    ) %>%
    { print(select(., VFC_ID, VFC, VF_ID, VF)); . } %>%
    mutate(
        rowsum = rowSums(select_numeric_columns(select(., 8:ncol(.))), na.rm = TRUE)
    
    ) %>%
    { print(select(., VFC_ID, VF_ID, rowsum)); . } %>%
    group_by(VFC) %>%
    arrange(VFC, desc(rowsum)) %>%
    mutate(
        row_index = row_number()
    ) %>%
    { print(select(., VFC, row_index)); . } %>%
    ungroup() %>%
    arrange(VFC, row_index)
print("What's going on ?3")

    print(head(heatmap_data_summarized))

    # VF 수가 90개 이상일 때 legend 줄이기
    if(n_distinct(as.character(heatmap_data_summarized$VF)) > 45) {
    top_45_vf <- heatmap_data_summarized %>%
        group_by(VF) %>%
        summarise(total_rowsum = sum(rowsum)) %>%
        top_n(45, total_rowsum) %>%
        pull(VF)
    heatmap_data_summarized <- heatmap_data_summarized %>%
        mutate(VF_display = ifelse(VF %in% top_45_vf, VF, "Other"))
    } else {
    heatmap_data_summarized$VF_display <- heatmap_data_summarized$VF
    }
    print(head(heatmap_data_summarized))


    heatmap_data_summarized$VFC <- factor(heatmap_data_summarized$VFC, levels = unique(heatmap_data_summarized$VFC))
    heatmap_data_summarized$VF_display <- factor(heatmap_data_summarized$VF_display, levels = unique(heatmap_data_summarized$VF_display))

    heatmap_data_summarized$VF_ID <- factor(heatmap_data_summarized$VF_ID)
    heatmap_data_summarized$VFC_ID <- factor(heatmap_data_summarized$VFC_ID)

    set.seed(33)
    vf_names <- unique(heatmap_data_summarized$VF_ID)
    vfc_categories <- unique(heatmap_data_summarized$VFC_ID)
    vf_colors <- rainbow(length(vf_names))
    vfc_colors <- rainbow(length(vfc_categories))
    vf_color_map <- setNames(vf_colors, vf_names)
    vfc_color_map <- setNames(vfc_colors, vfc_categories)
    head(vf_color_map)
    head(vfc_color_map)
    # heatmap_data_summarized$VF_ID <- factor(heatmap_data_summarized$VF_ID, levels = vf_names)
    # heatmap_data_summarized$VFC_ID <- factor(heatmap_data_summarized$VFC_ID, levels = vfc_categories)
    heatmap_data_summarized$VF_ID <- factor(heatmap_data_summarized$VF_ID, levels = names(vf_color_map))
    heatmap_data_summarized$VFC_ID <- factor(heatmap_data_summarized$VFC_ID, levels = names(vfc_color_map))

    all(names(vf_color_map) %in% levels(heatmap_data_summarized$VF_ID)) # Should return TRUE
    all(names(vfc_color_map) %in% levels(heatmap_data_summarized$VFC_ID)) # Should return TRUE

    head(heatmap_data_summarized)
    # metadata add 
    rownames(metadata) <- metadata[,1]

    selected_columns <- c("Completeness", "Contamination", "classification", colnames(metadata[selected_colname])) #meta1380 %>% select(ncol(.)))
    meta_filtered_forvis <- metadata[, selected_columns]
    head(meta_filtered_forvis)
    # meta_filtered_forvis$colnames(meta_filtered_forvis[selected_colname]) <- replace(meta_filtered_forvis$colnames(metadata[selected_colname]),
    #                                           meta_filtered_forvis$colnames(metadata[selected_colname])=='',"NA")
    meta_filtered_forvis <- meta_filtered_forvis %>%
    mutate(!!selected_colname := replace(.[[selected_colname]], .[[selected_colname]] == "", "NA"))

    print(meta_filtered_forvis)

    classification_split <- strsplit(as.character(meta_filtered_forvis$classification), ";")
    classification_df <- do.call(rbind, classification_split)
    colnames(classification_df) <- c("Domain", "Phylum", "Class", "Order", "Family", "Genus", "Species")
    classification_df <- as.data.frame(classification_df)

    meta_filtered_forvis <- cbind(meta_filtered_forvis[, -which(colnames(meta_filtered_forvis) == "classification")], classification_df)
    head(meta_filtered_forvis)

    meta_filtered_forvis_ordered <- meta_filtered_forvis[match(colnames(heatmap_data), rownames(meta_filtered_forvis)),]


    # top_annotation <- HeatmapAnnotation(df = meta_filtered_forvis_ordered,
    #                                     annotation_name_gp = gpar(fontsize = 7)) 

    print(levels(heatmap_data_summarized$VF_ID))
    print(levels(heatmap_data_summarized$VFC_ID))
    head(heatmap_data_summarized)

    row_annotation <-HeatmapAnnotation(
    VF_Name = heatmap_data_summarized$VF_display,
    VFcategory = heatmap_data_summarized$VFC,  
    #VF_ID = heatmap_data_summarized$VF_ID,
    #VFC_ID = heatmap_data_summarized$VFC_ID,
    which='row',
        annotation_name_gp = gpar(fontsize = 11, fontfamily = "Helvetica", fontface = "bold"),
    annotation_legend_param = list(
        title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface = "bold"),
        labels_gp = gpar(fontsize = 11, fontfamily = "Helvetica")
    )
    )

    row_annotation_hover <- HeatmapAnnotation(
    VF_ID = heatmap_data_summarized$VF_ID,
    VFC_ID = heatmap_data_summarized$VFC_ID,
    show_annotation_name = FALSE, 
    show_legend = FALSE,
    which = 'row',
    height = unit(0, "mm")  
    )
print("What's going on ?3")

    vfdb_matrix<- heatmap_data_summarized[,8:(ncol(heatmap_data_summarized) -5)]



    #asdasdasd
    breaks <- c(0, min(vfdb_matrix[vfdb_matrix>0]), max(vfdb_matrix))
    print(breaks)
    #doncha --> solved  last 5 field were attached 
    colors <- c("lightgrey", "white", "orange")
    vfdb_matrix <- as.matrix(heatmap_data_summarized[,8:(ncol(heatmap_data_summarized)-5)])
                                            
    # print(vfdb_matrix[(nrow(vfdb_matrix) - 5): nrow(vfdb_matrix), (ncol(vfdb_matrix) - 5): ncol(vfdb_matrix)])
    # print(vfdb_matrix[1:3,1:3])

    if (length(unique(as.vector(vfdb_matrix))) == 1) {
    my_color_function <- "orange"
    } else {
    my_color_function <- colorRamp2(breaks,colors)
    }

    basic_metadata <- meta_filtered_forvis_ordered[, !colnames(meta_filtered_forvis_ordered) %in% c(selected_colname,"Domain", "Phylum", "Class", "Order", "Family")]
    user_metadata <- meta_filtered_forvis_ordered[, selected_colname, drop = FALSE]
    print("Whatthe?4")

    print(vfdb_matrix[(nrow(vfdb_matrix) - 5):nrow(vfdb_matrix), (ncol(vfdb_matrix) - 5):ncol(vfdb_matrix)])

    print(vfdb_matrix[1:3,1:12])

    top_annotation_boxplot <- HeatmapAnnotation(Average_value = anno_boxplot(as.matrix(vfdb_matrix), axis = TRUE, height = unit(1.0, "cm"),
                                axis_param = list(labels_rot = 0)),
    annotation_name_side = "left", annotation_name_rot = 0,
    annotation_name_gp = gpar(fontsize = 11, fontfamily = "Helvetica", fontface="bold")
    )

    print("Whatthe?5")
    top_annotation_basic <- HeatmapAnnotation(
    df = basic_metadata,
    annotation_name_side = "left",
    annotation_name_gp = gpar(fontsize = 11, fontfamily = "Helvetica", fontface="bold"),
    annotation_legend_param = list(
        title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface = "bold"),
        labels_gp = gpar(fontsize = 11, fontfamily = "Helvetica")
    )
    )
    print("Whatthe?6")
    top_annotation_user <- HeatmapAnnotation(
    df = user_metadata,
    annotation_name_side = "left",
    annotation_name_gp = gpar(fontsize = 11, fontfamily = "Helvetica", col = "red", fontface="bold"),
    annotation_legend_param = list(
        title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface = "bold"),
        labels_gp = gpar(fontsize = 11, fontfamily = "Helvetica")
    )
    )

    split_data <- split(as.data.frame(t(vfdb_matrix)), meta_filtered_forvis_ordered[, selected_colname])
    split_matrix <- do.call(cbind, lapply(split_data, function(x) colMeans(x, na.rm = TRUE)))

    distribution_colors <- scales::hue_pal()(ncol(split_matrix))
    distribution_legend <- Legend(
        labels = colnames(split_matrix),
        legend_gp = gpar(fill = distribution_colors),
        title = "Virulence_factor_averages",
        title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface="bold"),
        labels_gp = gpar(fontsize = 11, fontfamily = "Helvetica")    
    )

    left_annotation <- rowAnnotation(
    Virulence_factor_averages= anno_points(split_matrix, 
                                pch = 1:ncol(split_matrix),
                                size = unit(1, "mm"),
                                title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface="bold"),
                                gp = gpar(col = scales::hue_pal()(ncol(split_matrix))),
                                width = unit(3, "cm")
    ),  
    annotation_name_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface="bold")
    )


    ht1 <- Heatmap(
    as.matrix(heatmap_data_summarized[,8:(ncol(heatmap_data_summarized)-5)]),
    name = "Virulence Factors",
    col = my_color_function,
    top_annotation = c(top_annotation_boxplot, top_annotation_basic, top_annotation_user),
    right_annotation = c(row_annotation,row_annotation_hover),
    #right_annotation = row_annotation,
    left_annotation = left_annotation,
    show_row_names = FALSE,
    show_column_names = FALSE,
    show_column_dend = FALSE,
    row_order = order(as.integer(factor(heatmap_data_summarized$VFC)), heatmap_data_summarized$row_index),  # VFC,VF arrange
    column_split  = meta_filtered_forvis_ordered[,selected_colname],
    heatmap_legend_param = list(
        legend_direction = "horizontal",
        title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface="bold"),
        labels_gp = gpar(fontsize = 11, fontfamily = "Helvetica")
    ),
    row_names_gp = gpar(fontsize = 11, fontfamily = "Helvetica"),
    column_names_gp = gpar(fontsize = 11, fontfamily = "Helvetica"),
    column_title_gp = gpar(fontsize = 12, fontfamily = "Helvetica", fontface = "bold", col = "blue")  
    )
    # Save heatmap to file
    #output_file <- "heatmap_VFDB.pdf"

    pdf_width <- (2.5*ncol(vfdb_matrix) + 90 + 110 + 100) / 25.4
    pdf_height <- (2.5*nrow(vfdb_matrix) + 45 + 40 + 40) / 25.4

    if (pdf_width >= 20.9) {
    pdf_width = 20.9
    }

    if (pdf_height >= 15) {
    pdf_height = 15.65
    }

    library(ragg)
    library(ComplexHeatmap)
    library(circlize)
    library(InteractiveComplexHeatmap)

    ht1 <- draw(ht1,
        padding = unit(c(2, 2, 2, 2), "cm"),
        annotation_legend_list = list(distribution_legend),
        annotation_legend_side = "left"
    )
    # pdf(file = output_file, width = pdf_width, height = pdf_height)
    # #pdf(file = output_file, width = 20, height = 15)
    # draw(heatmap)
    # dev.off()
 return(list(
    plot = ht1,
    data = heatmap_data_summarized,#,
    gene_vf_info = gene_vf_info
  ))
    
#htShiny(heatmap, output_ui_float = TRUE, save = output_html)
}

##############################
# heatmap data parsing for brush action 
# heatmap data parsing for brush action 
process_dbcan_data <- function(selected_data, result) {
  # HMMER 정보 추출
  hmmer_info <- result$data$HMMER[as.numeric(rownames(selected_data))]

  # gene_data에서 관련 정보 추출
  gene_info <- result$gene_data %>%
    dplyr::filter(HMMER %in% hmmer_info) %>%
    dplyr::group_by(HMMER) %>%
    dplyr::summarise(
      `Gene IDs` = paste(unique(Gene), collapse = "; ")#,
      #`Genome Count` = n_distinct(Genome),
      #`Total Count` = n()
    )

  # 선택된 데이터와 gene 정보 결합
  result_table <- selected_data %>%
    dplyr::mutate(HMMER = hmmer_info)
    #tibble::rownames_to_column("HMMER") %>%
    dplyr::left_join(gene_info, by = "HMMER") %>%
    dplyr::select(HMMER, `Gene IDs`, dplyr::everything())

  return(result_table)
}


# heatmap data parsing for brush action 
# heatmap data parsing for brush action 
##############################

# List of CSV files in the directory
csv_directory <- "."
csv_files <- list.files(csv_directory, pattern = "*.csv", full.names = TRUE)
csv_file_names <- basename(csv_files)  # Get just the file names for display


#########
# assocation analyzer
load_data <- function() {
  
  gene_pa <- read.table("gene_presence_absence.Rtab", header = TRUE, sep = "\t", row.names = 1, check.names = FALSE)
  #gene_count <- read.table("gene_count_matrix.tsv",header = TRUE, sep = "\t", row.names = 1, check.names = FALSE)
  
  if (file.exists("test.csv")) {
    metadata <- read.csv("test.csv", header = TRUE, row.names = 1)
  } else {
    metadata <- data.frame(row.names = colnames(gene_pa))
    metadata$default_category <- rep("Default", ncol(gene_pa))
  }
  list(gene_pa = gene_pa, metadata = metadata)
}


process_matrix_partition <- function(gene_partition, category, current_category, p_value_threshold) {
  p_values <- apply(gene_partition, 1, perform_fisher_test, category = category, current_category = current_category)
  significant_indices <- which(p_values <= p_value_threshold)
  
  if (length(significant_indices) > 0) {
    result_df <- data.frame(
      gene_id = rownames(gene_partition)[significant_indices],
      p_value = p_values[significant_indices],
      category = current_category,
      stringsAsFactors = FALSE
    )
    # gene_id와 category를 결합하여 고유한 행 이름 생성
    rownames(result_df) <- paste0(result_df$gene_id, "_", result_df$category)
    return(result_df)
  } else {
    return(data.frame(gene_id = character(), p_value = numeric(), category = character(), stringsAsFactors = FALSE))
  }
}

is_numeric_and_sufficient <- function(x) {
  is.numeric(x) && length(unique(x)) > 3
}
perform_fisher_test <- function(gene_row, category, current_category) {
  contingency_table <- table(factor(gene_row, levels = c(0, 1)),
                             factor(category == current_category, levels = c(FALSE, TRUE)))
  fisher_result <- fisher.test(contingency_table)
  return(fisher_result$p.value)
}

process_category <- function(current_category, gene_pa, category, num_cores, p_value_threshold) {
  # Partition the matrix
  total_genes <- nrow(gene_pa)
  genes_per_core <- ceiling(total_genes / num_cores)
  
  partitions <- lapply(seq_len(num_cores), function(i) {
    start_index <- (i - 1) * genes_per_core + 1
    end_index <- min(i * genes_per_core, total_genes)
    gene_pa[start_index:end_index, , drop = FALSE]
  })
  
  # Parallel processing
  cl <- parallel::makeCluster(num_cores)
  parallel::clusterExport(cl, c("perform_fisher_test", "process_matrix_partition"))
  
  results <- parallel::parLapply(cl, partitions, function(partition) {
    process_matrix_partition(partition, category, current_category, p_value_threshold)
  })
  
  parallel::stopCluster(cl)
  
  # Combine results
  combined_results <- do.call(rbind, results)
  if (nrow(combined_results) > 0) {
    combined_results$category_value <- current_category
  }
  
  return(combined_results)
}

run_pyseer <- function(phenotype_file, gene_pa_file, cpu_count, phenotype_name) {
  output_file <- paste0("pyseer_output_", phenotype_name)
  #cmd <- sprintf("conda activate pyseer &&pyseer --phenotypes %s --pres %s --continuous --cpu %d --distances skani_ANI_dist.tsv > %s", 
   #              phenotype_file, gene_pa_file, cpu_count, output_file)
  
  full_cmd <- sprintf("source ~/.bashrc && conda activate pyseer && pyseer --phenotypes %s --pres %s --continuous --cpu %d --distances skani_ANI_dist.tsv > %s", 
                       phenotype_file, gene_pa_file, cpu_count, output_file)
  
  # shell script 
  cmd <- sprintf("bash -c '%s'", full_cmd)

  system(cmd)
  
    result_df <- read.table(output_file, header = TRUE, sep = "\t", quote = "", stringsAsFactors = FALSE)
   numeric_cols <- c("af", "filter.pvalue", "lrt.pvalue", "beta", "beta.std.err", "intercept", paste0("PC", 1:10))
   result_df[numeric_cols] <- lapply(result_df[numeric_cols], function(x) as.numeric(as.character(x)))
  
  return(result_df)
}
# assocation analyzer
#########

# script for sequence family finder 
# prokka basename 
extract_prokka_prefix <- function(id) {
  parts <- strsplit(sub("gnl\\|Prokka\\|", "", id), "_")[[1]]
  return(parts[1])
}


sequence_family_finder <- function(query, h5file, input_metadata_file) {
  # 1. Gene Family 검색
  tryCatch({
    gene_families <- h5read(h5file, "gene_families")
    family_members <- gene_families[gene_families$family_representative == query |
                                    gene_families$member == query, ]
  }, error = function(e) {
    message("Error reading gene families: ", e$message)
    family_members <- data.frame()
  })

  # 2. 시퀀스 검색
  faa_seqs <- list()
  ffn_seqs <- list()

    tryCatch({
    # FAA 시퀀스 검색
    faa_data <- h5read(h5file, "faa_sequences")
    faa_matches <- which(faa_data[,1] %in% family_members$member)
    if (length(faa_matches) > 0) {
      faa_seqs <- setNames(as.list(faa_data[faa_matches, 2]), faa_data[faa_matches, 1])
    }

    # FFN 시퀀스 검색
    ffn_data <- h5read(h5file, "ffn_sequences")
    ffn_matches <- which(ffn_data[,1] %in% family_members$member)
    if (length(ffn_matches) > 0) {
      ffn_seqs <- setNames(as.list(ffn_data[ffn_matches, 2]), ffn_data[ffn_matches, 1])
    }
  }, error = function(e) {
    message("Error reading sequences: ", e$message)
  })





    # # HDF5 파일의 구조 가져오기
    # h5_structure <- h5ls(h5file)
    # faa_groups <- h5_structure$name[h5_structure$group == "/faa_sequences" & !grepl("_headers$", h5_structure$name)]
    # ffn_groups <- h5_structure$name[h5_structure$group == "/ffn_sequences" & !grepl("_headers$", h5_structure$name)]

    # for (member in family_members$member) {
    #     member_prefix <- extract_prokka_prefix(member)
        
    #     # FAA 시퀀스 검색
    #     for (group in faa_groups) {
    #     tryCatch({
    #         faa_headers <- h5read(h5file, paste0("/faa_sequences/", group, "_headers"))
    #         match_index <- which(faa_headers == member)
    #         if (length(match_index) > 0) {
    #         faa_sequences <- h5read(h5file, paste0("/faa_sequences/", group))
    #         faa_seqs[[member]] <- faa_sequences[match_index]
    #         print(paste("FAA sequence found for", member))
    #         break
    #         }
    #     }, error = function(e) {
    #         message("Error reading FAA sequence for ", member, ": ", e$message)
    #     })
    #     }
        
    #     # FFN 시퀀스 검색
    #     for (group in ffn_groups) {
    #     tryCatch({
    #         ffn_headers <- h5read(h5file, paste0("/ffn_sequences/", group, "_headers"))
    #         match_index <- which(ffn_headers == member)
    #         if (length(match_index) > 0) {
    #         ffn_sequences <- h5read(h5file, paste0("/ffn_sequences/", group))
    #         ffn_seqs[[member]] <- ffn_sequences[match_index]
    #         print(paste("FFN sequence found for", member))
    #         break
    #         }
    #     }, error = function(e) {
    #         message("Error reading FFN sequence for ", member, ": ", e$message)
    #     })
    #     }
    # }

  # 3. 메타데이터 처리
  tryCatch({
    all_metadata <- h5read(h5file, "sequence_metadata")
    
    relevant_metadata <- data.frame()
    for (member in family_members$member) {
      member_prefix <- extract_prokka_prefix(member)
      member_metadata <- all_metadata[all_metadata$prokka_prefix == member_prefix, ]
      if (nrow(member_metadata) > 0) {
        member_metadata$member_id <- member
        member_metadata$representative_id <- family_members$family_representative[family_members$member == member]
        relevant_metadata <- rbind(relevant_metadata, member_metadata)
      }
    }
    
    input_metadata <- read.csv(input_metadata_file, header = TRUE, check.names = FALSE)
    
    # 중복 열 제거 및 병합
    relevant_metadata <- merge(relevant_metadata, input_metadata, by.x = "genome_id", by.y = "Name", all.x = TRUE, suffixes = c("", "_input"))
    
    # 중복된 열 제거
    duplicate_cols <- grep("_input$", names(relevant_metadata), value = TRUE)
    relevant_metadata <- relevant_metadata[, !names(relevant_metadata) %in% duplicate_cols]
    
    # 열 순서 재정렬
    relevant_metadata <- relevant_metadata %>%
      dplyr::select(member_id, representative_id, dplyr::everything())
    
  }, error = function(e) {
    message("Error processing metadata: ", e$message)
    relevant_metadata <- data.frame()
  })


  print("Final FAA sequences:")
  print(names(faa_seqs))
  print("Final FFN sequences:")
  print(names(ffn_seqs))
  
  return(list(
    family = family_members,
    faa = faa_seqs,
    ffn = ffn_seqs,
    metadata = relevant_metadata
  ))
}




#run_mafft <- function(input_file, output_file, threads) {
#  system(paste("/home/metafun/miniforge3/envs/R_heatmap/bin/mafft --thread", threads, input_file, ">", output_file))
#}
# run_mafft <- function(input_file, output_file, threads, log_file) {
#   cat("Starting MAFFT alignment\n", file = log_file, append = TRUE)

#   cmd <- paste("/home/metafun/miniforge3/envs/R_heatmap/bin/mafft --thread", threads, input_file, ">", output_file)
#   cat(paste("Running MAFFT command:", cmd, "\n"), file = log_file, append = TRUE)
#   result <- system(cmd, intern = TRUE)
#   cat(paste("MAFFT output:", paste(result, collapse = "\n"), "\n"), file = log_file, append = TRUE)
# }

run_mafft <- function(input_file, output_file, threads, log_file) {
  cat("Starting MAFFT alignment\n", file = log_file, append = TRUE)

  # 입력 파일 확인
  cat(paste("Input file:", input_file, "\n"), file = log_file, append = TRUE)
  if (file.exists(input_file)) {
    cat(paste("Input file size:", file.size(input_file), "bytes\n"), file = log_file, append = TRUE)
  } else {
    cat("Error: Input file does not exist\n", file = log_file, append = TRUE)
    return()
  }

  # MAFFT 명령어 구성
    #cmd <- paste("/home/metafun/miniforge3/envs/R_heatmap/bin/mafft --thread", threads, input_file, ">", output_file, "2>&1")
  cmd <- paste("/home/metafun/miniforge3/envs/R_heatmap/bin/mafft --thread", threads, input_file, ">", output_file, "2>", paste0(output_file, ".log"))

  cat(paste("Running MAFFT command:", cmd, "\n"), file = log_file, append = TRUE)

  # MAFFT 실행 및 출력 캡처
  result <- system(cmd, intern = TRUE)

  # MAFFT 출력 로깅
  cat("MAFFT output:\n", file = log_file, append = TRUE)
  cat(paste(result, collapse = "\n"), "\n", file = log_file, append = TRUE)

  # 결과 파일 확인
  if (file.exists(output_file)) {
    cat(paste("Output file created:", output_file, "\n"), file = log_file, append = TRUE)
    cat(paste("Output file size:", file.size(output_file), "bytes\n"), file = log_file, append = TRUE)
    
    # 출력 파일의 처음 몇 줄 확인
    tryCatch({
      output_content <- readLines(output_file, n = 10)
      cat("First 10 lines of output file:\n", file = log_file, append = TRUE)
      cat(paste(output_content, collapse = "\n"), "\n", file = log_file, append = TRUE)
    }, error = function(e) {
      cat(paste("Error reading output file:", e$message, "\n"), file = log_file, append = TRUE)
    })
  } else {
    cat("Error: Output file not created\n", file = log_file, append = TRUE)
  }
}


#  generate phylogenetic tree 
# run_fasttree <- function(input_file, output_file, model, threads) {
#     Sys.setenv(OMP_NUM_THREADS = threads)

#   if (model == "LG") {
#     cmd <- paste("/home/metafun/miniforge3/envs/R_heatmap/bin/FastTree -lg -gamma ",  "-out", output_file, input_file)
#   } else if (model == "GTR") {
#     cmd <- paste("/home/metafun/miniforge3/envs/R_heatmap/bin/FastTree -gtr -gamma -nt ", "-out", output_file, input_file)
#   }
#   system(cmd)
# }

run_fasttree <- function(input_file, output_file, model, threads, log_file) {
  Sys.setenv(OMP_NUM_THREADS = threads)
  #  log_file_fasttree <- paste0(output_file, ".log")

  if (model == "LG") {
    cmd <- paste("/home/metafun/miniforge3/envs/R_heatmap/bin/FastTree -lg -gamma", input_file, ">", output_file, "2>>", log_file)
  } else if (model == "GTR") {
    cmd <- paste("/home/metafun/miniforge3/envs/R_heatmap/bin/FastTree -gtr -gamma -nt", input_file, ">", output_file, "2>>", log_file)
  }
  
  cat(paste("Running FastTree command:", cmd, "\n"), file = log_file, append = TRUE)
  
  
  
  
  # FastTree 실행 및 출력 캡처
  result <- system(cmd, intern = TRUE)
  
  # FastTree 출력 로깅
  cat("FastTree output:\n", file = log_file, append = TRUE)
  cat(paste(result, collapse = "\n"), "\n", file = log_file, append = TRUE)
  
  # 결과 파일 확인
  if (file.exists(output_file)) {
    cat(paste("Output file created:", output_file, "\n"), file = log_file, append = TRUE)
    cat(paste("Output file size:", file.size(output_file), "bytes\n"), file = log_file, append = TRUE)
    
    # 출력 파일의 내용 확인
    tree_content <- readLines(output_file)
    cat("Tree file contents:\n", file = log_file, append = TRUE)
    cat(paste(tree_content, collapse = "\n"), "\n", file = log_file, append = TRUE)
  } else {
    stop(paste("Error: Tree file not created -", output_file))
  }
}




create_tree <- function(input_file, output_dir, seq_type, threads, base_name) {
  log_file <- file.path(output_dir, paste0(base_name, "_tree_log.txt"))
  tree_file <- file.path(output_dir, paste0(base_name, "_tree.nwk"))

  cat("Starting tree creation process\n", file = log_file)
  cat(paste("Input file:", input_file, "\n"), file = log_file, append = TRUE)
  cat(paste("Output directory:", output_dir, "\n"), file = log_file, append = TRUE)
  cat(paste("Sequence type:", seq_type, "\n"), file = log_file, append = TRUE)
  cat(paste("Threads:", threads, "\n"), file = log_file, append = TRUE)

  cat("Input file contents:\n", file = log_file, append = TRUE)
  cat(paste(readLines(input_file), collapse = "\n"), "\n", file = log_file, append = TRUE)

  cat("Output directory permissions:\n", file = log_file, append = TRUE)
  cat(paste(system(paste("ls -l", output_dir), intern = TRUE), collapse = "\n"), "\n", file = log_file, append = TRUE)
  
  cat("Environment variables:\n", file = log_file, append = TRUE)
  env_vars <- Sys.getenv()
  cat(paste(names(env_vars), env_vars, sep = "=", collapse = "\n"), "\n", file = log_file, append = TRUE)

    print(paste("seq_type:", seq_type))
  # MAFFT로 정렬
  aligned_file <- file.path(output_dir, paste0(base_name, "_aligned.fasta"))
  

  # cat("Running MAFFT alignment\n", file = log_file, append = TRUE)
  # tryCatch({
  #   run_mafft(input_file, aligned_file, threads)
  #   cat("MAFFT alignment completed successfully\n", file = log_file, append = TRUE)
  # }, error = function(e) {
  #   cat(paste("Error in MAFFT alignment:", e$message, "\n"), file = log_file, append = TRUE)
  #   stop(paste("Error in MAFFT alignment:", e$message))
  # })
  cat("Running MAFFT alignment\n", file = log_file, append = TRUE)
  tryCatch({
    run_mafft(input_file, aligned_file, threads, log_file)
    cat("MAFFT alignment completed successfully\n", file = log_file, append = TRUE)
  }, error = function(e) {
    cat(paste("Error in MAFFT alignment:", e$message, "\n"), file = log_file, append = TRUE)
    cat(paste("Error call:", conditionCall(e), "\n"), file = log_file, append = TRUE)
    stop(paste("Error in MAFFT alignment:", e$message))
  })
  #run_mafft(input_file, aligned_file, threads)
  
  # FastTree로 트리 생성
  #tree_file <- file.path(output_dir, paste0(base_name, "_tree.nwk"))
#  tree_file <- file.path(output_dir, "tree.nwk")
  model <- if(seq_type == "faa") "LG" else "GTR"
  cat(paste("Running FastTree with model:", model, "\n"), file = log_file, append = TRUE)


  tryCatch({
    run_fasttree(aligned_file, tree_file, model, threads, log_file)
    cat("FastTree completed successfully\n", file = log_file, append = TRUE)
  }, error = function(e) {
    cat(paste("Error in FastTree:", e$message, "\n"), file = log_file, append = TRUE)
    stop(paste("Error in FastTree:", e$message))
  })




  cat("Reading tree file\n", file = log_file, append = TRUE)
  cat("Tree file contents:\n", file = log_file, append = TRUE)

  cat("Reading tree file\n", file = log_file, append = TRUE)
  tryCatch({
    tree <- ape::read.tree(tree_file)
    if (is.null(tree)) {
      stop("Tree is NULL after reading")
    }
    cat("Tree file read successfully\n", file = log_file, append = TRUE)
    
    cat(paste("Class of tree:", class(tree), "\n"), file = log_file, append = TRUE)
    cat("Structure of tree:\n", file = log_file, append = TRUE)
    capture.output(str(tree), file = log_file, append = TRUE)
    cat(paste("\nNumber of tips:", length(tree$tip.label), "\n"), file = log_file, append = TRUE)
    cat(paste("Number of internal nodes:", tree$Nnode, "\n"), file = log_file, append = TRUE)
    cat(paste("Edge matrix dimensions:", paste(dim(tree$edge), collapse = "x"), "\n"), file = log_file, append = TRUE)
    cat(paste("Length of edge.length:", length(tree$edge.length), "\n"), file = log_file, append = TRUE)
    cat(paste("First few tip labels:", paste(head(tree$tip.label), collapse = ", "), "\n"), file = log_file, append = TRUE)
  }, error = function(e) {
    cat(paste("Error reading tree file:", e$message, "\n"), file = log_file, append = TRUE)
    tree_content <- readLines(tree_file)
    cat("Tree file contents:\n", file = log_file, append = TRUE)
    cat(paste(tree_content, collapse = "\n"), "\n", file = log_file, append = TRUE)
    stop(paste("Error reading tree file:", e$message))
  })
  #tree <- ape::read.tree(tree_file)

 duplicated_tips <- tree$tip.label[duplicated(tree$tip.label)]
  if (length(duplicated_tips) > 0) {
    cat(paste("Duplicated tip labels found:", paste(duplicated_tips, collapse = ", "), "\n"), file = log_file, append = TRUE)
  } else {
    cat("No duplicated tip labels.\n", file = log_file, append = TRUE)
  }


  
perturb_tree <- function(tree, epsilon = 1e-10) {
  # Perturb branch lengths by adding a very small value
  #tree$edge.length <- tree$edge.length + runif(length(tree$edge.length), min = 0, max = epsilon)
  tree$edge.length[tree$edge.length == 0] <- 1e-10

  return(tree)
}
# https://stackoverflow.com/questions/51261388/duplicate-tips-label-removal-importing-phylogenetic-tree-in-r-for-comparison
handle_duplicate_node_labels <- function(tree) {
  duplicated_nodes <- tree$node.label[duplicated(tree$node.label)]
  if (length(duplicated_nodes) > 0) {
    cat("Duplicated node labels found and set to NULL:", duplicated_nodes, "\n")
    tree$node.label <- NULL
  } else {
    cat("No duplicated node labels.\n")
  }
  return(tree)
}

duplicated_nodes <- tree$node.label[duplicated(tree$node.label)]
if (length(duplicated_nodes) > 0) {
  cat("Duplicated node labels found:", duplicated_nodes, "\n")
} else {
  cat("No duplicated node labels.\n")
}

  cat("Perturbing tree\n", file = log_file, append = TRUE)
  tree <- perturb_tree(tree, 1e-10)
    cat("Handling duplicate node labels\n", file = log_file, append = TRUE)
  tree <- handle_duplicate_node_labels(tree)

    cat("Mid point rooting\n", file = log_file, append = TRUE)
  tree <- phytools::midpoint_root(tree)
 
 cat("Tree creation process completed\n", file = log_file, append = TRUE)
  return(list(tree = tree, aligned_file = aligned_file, tree_file = tree_file, log_file = log_file))  
}

visualize_tree <- function(tree, metadata, color_column, lambda = NULL) {


    #cat("Starting tree visualization\n", file = log_file, append = TRUE)
  #cat(paste("Class of tree:", class(tree), "\n"), file = log_file, append = TRUE)
   
  if (!is.null(metadata) && !is.null(color_column)) {
   # cat("Reding tree data using as_tibble\n", file = log_file, append = TRUE)
    tree_data <- as_tibble(tree)
    

    #tree_data <- as_tibble(phytools::midpoint_root(tree))
    #cat("Combining metadata\n", file = log_file, append = TRUE)
    combined_data <- dplyr::left_join(tree_data, metadata, by = c("label" = "member_id"))
     p <- ggtree::ggtree(tree)

print(names(combined_data))
    tip_data <- p$data %>%
      dplyr::filter(isTip) %>%
      dplyr::inner_join(combined_data, by = c("label" = "label"))
    
    tip_data <- tip_data %>%
      dplyr::mutate(hover_info = apply(tip_data, 1, function(row) {
        paste(names(row), row, sep = ": ", collapse = "<br>")
      }))

    main_title <- paste("Phylogenetic tree of", color_column)
    subtitle <- if (!is.null(lambda)) paste("Pagel's lambda =", round(lambda, 5)) else NULL

    p <- p + 
    ggtree::geom_point(data = tip_data, 
    aes (x = x , y = y, 
    color = !!rlang::sym(color_column),
    label = label)
                    ) +
      theme(legend.position = "right") +
        ggtitle(label = main_title, subtitle = subtitle)  # static 버전에 제목과 부제목 추가


    interactive_plot <- plotly::ggplotly(p)  %>%
      plotly::layout(title = list(text = paste0(main_title,
                                        '<br>',
                                        '<sup>',
                                        subtitle,
                                        '</sup>')))

  } else {
    p <- ggtree(tree) #+ geom_tippoint(aes(color = color_column))
    interactive_plot <- plotly::ggplotly(p) 
  }

  return(list(static = p, interactive = interactive_plot))
  
}

perform_statistical_analysis <- function(tree, metadata, color_column) {


  #cat("Starting statistical analysis\n", file = log_file, append = TRUE)
  #cat(paste("Class of tree:", class(tree), "\n"), file = log_file, append = TRUE)

  # transform the tree to utilize  fitdiscrete 
  #tree <- phytools::midpoint_root(tree)
  tree <- ape::multi2di(tree)

   # use geiger fitciscrete lambda for categorical variable. 
    if (is.factor(metadata[[color_column]]) || is.character(metadata[[color_column]])) { 
    cat("Trait type: Categorical\n")
    trait <- as.factor(metadata[[color_column]])
    names(trait) <- metadata$member_id

    trait_data <- data.frame(trait = trait)

# check unique category number 
    unique_categories <- unique(trait)
    if (length(unique_categories) == 1) {
      cat("Only one category present. Skipping Pagel's lambda analysis.\n")
      return(list(
        statistic = "None",
        lambda = NA,
        p_value = NA,
        log_output = "Only one category present. Pagel's lambda analysis skipped."
      ))
    }

    # Prepare data for geiger
    td <- geiger::treedata(tree, trait)
    tree <- td$phy
    trait <- td$data
    # Fit model with lambda transformation
    
    fit_lambda <- geiger::fitDiscrete(tree, trait, type="discrete",model="ARD", transform= "lambda", niter= 500 )
#  print(fit_lambda)

    log_output <- capture.output({
      print(fit_lambda)
      print(paste("Lambda value: ", fit_lambda$opt$lambda))
      print(paste("AIC: ", fit_lambda$opt$aic))
    })

  return(list(
      statistic = "fitDiscrete",
      model = "ARD",
      AIC = fit_lambda$opt$aic,
      lambda = fit_lambda$opt$lambda,
      fit_result = fit_lambda,
      log_output = log_output
    ))
    # )
 } else {
    cat("Trait type: Continuous\n")

    trait <- metadata[[color_column]]
    names(trait) <- metadata$member_id

    #lambda <- fit$lambda    
    complete_cases <- !is.na(trait)
    trait <- trait[complete_cases]
    #metadata <- metadata[complete_cases, ]
    tree <- ape::drop.tip(tree, tree$tip.label[!tree$tip.label %in% names(trait)])

    lambda_result <- phytools::phylosig(tree, trait, method = "lambda", test = TRUE)
    #fit <- fitContinuous(tree, trait, model="lambda")

    log_output <- capture.output({
      print(lambda_result)
    })

    return(list(
      statistic = "Pagel's lambda", 
      lambda = lambda_result$lambda, 
      p_value = lambda_result$P,
      log_output = log_output
    ))
  }
}


run_phylogenetic_analysis <- function(input_file, output_dir, seq_type, threads, metadata = NULL, color_column = NULL, file_base_name = NULL) {
  
  base_name <- if (!is.null(file_base_name) && file_base_name != "") file_base_name else color_column  
  
  log_file <- file.path(output_dir, paste0(base_name, "_analysis_log.txt"))

  #log_file <- file.path(output_dir, "debug_log.txt")
  cat("Starting phylogenetic analysis\n", file = log_file, append = TRUE)
  cat(paste("Input file:", input_file, "\n"), file = log_file, append = TRUE)    
  #cat("Session Info:\n", file = log_file, append = TRUE)
  #cat(capture.output(sessionInfo()), file = log_file, append = TRUE, sep = "\n")
  cat(paste("Output directory:", output_dir, "\n"), file = log_file, append = TRUE)
  cat(paste("Threads:", threads, "\n"), file = log_file, append = TRUE)

  cat("Environment variables:\n", file = log_file, append = TRUE)
  cat(paste("R_HOME:", Sys.getenv("R_HOME"), "\n"), file = log_file, append = TRUE)
  cat(paste("PATH:", Sys.getenv("PATH"), "\n"), file = log_file, append = TRUE)
  cat(paste("LD_LIBRARY_PATH:", Sys.getenv("LD_LIBRARY_PATH"), "\n"), file = log_file, append = TRUE)



  cat("\n", file = log_file, append = TRUE)

  dir.create(output_dir, showWarnings = FALSE, recursive = TRUE)

  print("Starting phylogenetic analysis")
  print(paste("Input file:", input_file))
  print(paste("Output directory:", output_dir))
  print(paste("Sequence type:", seq_type))
  
  cat("Reading sequences...\n", file = log_file, append = TRUE)

  if (seq_type == "faa") {
    sequences <- Biostrings::readAAStringSet(input_file)
  } else if (seq_type == "ffn") {
    sequences <- Biostrings::readDNAStringSet(input_file)
  } else {
    stop("Invalid sequence type. Must be 'faa' or 'ffn'.")
  }
    cat(paste("Number of sequences read:", length(sequences), "\n"), file = log_file, append = TRUE)

  
  #print(paste("Number of sequences read:", length(sequences)))
  if (!is.null(metadata) && !is.null(color_column)) {
    cat("Checking metadata...\n")
    print(paste("Missing values in", color_column, ":", sum(is.na(metadata[[color_column]]))))
    #metadata[[color_column]] <- as.factor(metadata[[color_column]])
  }
  base_name <- if (!is.null(file_base_name) && file_base_name != "") file_base_name else color_column
  
  cat("Creating phylogenetic tree...\n", file = log_file, append = TRUE)
  tree_result <- create_tree(input_file, output_dir, seq_type, threads, base_name)
    cat("Tree creation completed.\n", file = log_file, append = TRUE)


  tree <- tree_result$tree
      cat(paste("Class of tree:", class(tree), "\n"), file = log_file, append = TRUE)

  print("class tree")
  print(class(tree))

  print("str tree")
  print(str(tree))
  aligned_file <- tree_result$aligned_file
  tree_file <- tree_result$tree_file

  #cat(paste("Tree creation log file:", tree_log_file, "\n"), file = log_file, append = TRUE)
  cat(paste("Tree creation log file:", tree_result$log_file, "\n"), file = log_file, append = TRUE)

  if (!is.null(metadata)) {
    print(paste("All tree tips in metadata:", all(tree$tip.label %in% metadata$member_id)))
  }
  
  if (!is.null(metadata) && !is.null(color_column)) {
          cat("Performing statistical analysis...\n", file = log_file, append = TRUE)

    stat_result <- perform_statistical_analysis(tree, metadata, color_column)
        
    plot_file <- file.path(output_dir, paste0(base_name, "_phylogenetic_tree.png"))
    interactive_plot_file <- file.path(output_dir, paste0(base_name, "_phylogenetic_tree.html"))
    metadata_file <- file.path(output_dir, paste0(base_name, "_metadata.csv"))
    log_file <- file.path(output_dir, paste0(base_name, "_analysis_log.txt"))
    
    write.csv(metadata, metadata_file, row.names = FALSE)

    writeLines(stat_result$log_output, file.path(output_dir, paste0(base_name, "_analysis_log.txt")))
    
    # Lambda 값을 포함하여 트리 시각화

    lambda_value <- if (!is.null(stat_result$lambda)) stat_result$lambda else if (!is.null(stat_result$value)) stat_result$value else NULL
    plot_results <- visualize_tree(tree, metadata, color_column, lambda = lambda_value)
    ggsave(plot_file, plot_results$static, width = 12, height = 8)
    htmlwidgets::saveWidget(plot_results$interactive, interactive_plot_file)

    cat(paste0("Statistical analysis result:\n",
               "Statistic: ", stat_result$statistic, "\n",
               "Lambda: ", lambda_value, "\n",
               if(!is.null(stat_result$p_value)) paste0("p-value: ", stat_result$p_value, "\n") else ""))
 } else {
    plot_results <- NULL
    stat_result <- NULL
    metadata_file <- NULL
    log_file <- NULL
  }

  return(list(
    tree = tree,
    plot = plot_results,
    stat_result = stat_result,
    created_files = list(
      aligned_file = aligned_file,
      tree_file = tree_file,
      plot_file = if(!is.null(plot_results)) plot_file else NULL,
      interactive_plot_file = if(!is.null(plot_results)) interactive_plot_file else NULL,
      metadata_file = metadata_file,
      log_file = log_file,
      tree_log_file = tree_result$log_file  

    )
  ))
}










# UI ui definition 
ui <- navbarPage(

  title = div(
    style = "display: flex; align-items: center; height: 100%;",
    tags$img(src = 'shiny_metafun_face.png', height = "30px", style = "margin-right: 10px;"),
    "metaFun: INTERACTIVE_ANNOTATOR"
  ),
  header = tags$head(
    tags$script(HTML("
      $(document).ready(function() {
        var header = $('.navbar > .container-fluid');
        header.append('<div style=\"display: flex; align-items: center; height: 100%; margin-left: auto;\"><a href=\"https://github.com/aababc1/metaFun\" target=\"_blank\"><i class=\"fab fa-github\" style=\"font-size:24px;color:white;margin-right:15px;\"></i></a><a href=\"https://metafun-doc.readthedocs.io/en/latest/index.html\" target=\"_blank\"><i class=\"fas fa-book\" style=\"font-size:24px;color:white;margin-right:15px;\"></i></a><a href=\"https://www.microbiome.re.kr/home_design/Database.html\" target=\"_blank\"><img src=\"shiny_MGSSB.png\" alt=\"MGSSB\" style=\"height:30px;width:auto;\"></a></div>');
        //header.append('<div style=\"display: flex; align-items: center; height: 100%; margin-left: auto;\"><a href=\"https://github.com/aababc1/metaFun\" target=\"_blank\"><i class=\"fab fa-github\" style=\"font-size:24px;color:white;margin-right:15px;\"></i></a><a href=\"https://metafun-doc.readthedocs.io/en/latest/index.html\" target=\"_blank\"><i class=\"fas fa-book\" style=\"font-size:24px;color:white;margin-right:15px;\"></i></a><a href=\"https://www.microbiome.re.kr/home_design/Database.html\" target=\"_blank\"><img src=\"shiny_MGSSB.png\" alt=\"MGSSB\" style=\"height:30px;width:auto;\"></a></div>');

        $('.navbar-header').css('float', 'none');
        $('.navbar > .container-fluid').css('display', 'flex').css('align-items', 'center');
      });
    ")),
    tags$link(rel = "stylesheet", href = "https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css"),
    tags$style(HTML("
      .navbar { min-height: 60px; }
      .navbar > .container-fluid { display: flex; align-items: center; }
      .navbar-brand { height: auto; display: flex; align-items: center; }
    "))
  ),

#  UI Theme 
  theme = shinytheme("flatly"),
  useShinyjs(),
  tags$head(
    tags$link(rel="icon",  type = "image/x-icon",href="metafun5_sky.png"),
    tags$script(HTML("
      $(document).on('shiny:connected', function() {
        var container = document.querySelector('.tall-tab-content');
        var iframe = container.querySelector('iframe');
        
        function updateIframeSize() {
            if (!iframe) {
            iframe = container.querySelector('iframe');
            if (!iframe) return;
            }
            var newHeight = container.offsetHeight;
            var newWidth = container.offsetWidth;
            iframe.style.height = newHeight + 'px';
            iframe.style.width = newWidth + 'px';
            Shiny.onInputChange('containerHeight', newHeight);
            Shiny.onInputChange('containerWidth', newWidth);
        }

        var resizeObserver = new ResizeObserver(updateIframeSize);
        resizeObserver.observe(container);
        window.addEventListener('resize', updateIframeSize);

        // Check for iframe every 100ms until it's available
        var checkInterval = setInterval(function() {
            if (container.querySelector('iframe')) {
            clearInterval(checkInterval);
            updateIframeSize();
            }
        }, 100);
        });
    ")),
    tags$style(HTML("
      .sidebar { background-color: #f8f9fa; padding: 20px; border-right: 1px solid #dee2e6; }
      .main-content { padding: 20px; }
      .logo-container { display: flex; align-items: center; margin-bottom: 20px; }
      .logo-container img { margin-right: 10px; }
      .btn-generate { background-color: #007bff; color: white; }
      .btn-generate:hover { background-color: #0056b3; }
      .section-divider { border-top: 1px solid #dee2e6; margin: 15px 0; }
      .tall-tab-content { 
        width: 100%; 
        #height: calc(100vh ); 
      height: calc(100vh - 150px);        
        #height: 100%; 
        border: 1px solid; 
        overflow: hidden; /* auto 대신 hidden 사용 */
        resize: both;
      }
       .dataTables_wrapper {
       width: 100%;
       overflow-x: auto;
     }
     
     .tall-tab-content iframe {
        width: 100%;
        height: 100%; 
         #resize: vertical;  
         border: none;
       }    
/* spinner */
      #loading_spinner {
        display: none;
        position: fixed;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        z-index: 1000;
      }
    .spinner-container {
      display: none;
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      z-index: 1000;
      text-align: center;
    }      
      .spinner {
        border: 16px solid #f3f3f3;
        border-radius: 50%;
        border-top: 16px solid #3498db;
        width: 120px;
        height: 120px;
        animation: spin 2s linear infinite;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }


  ")),
  ),


    tabsetPanel(id = "main_tabs",
    
    tabPanel("Heatmap",  # new
    sidebarLayout(         #new
    sidebarPanel(         # new 
      h4("Heatmap Settings"),
      selectInput("heatmap_type", "Select Heatmap Type:",
                  choices = c("CARD", "dbCAN", "KEGG", "VFDB","ANI")),
      conditionalPanel(
        condition = "input.heatmap_type != 'KEGG' && input.heatmap_type != 'ANI'",
        selectInput("data_type", "Select Data Type:",
                    choices = c("Gene presence/absence", "Gene count"))
      ), 
      selectInput("meta_col", "Metadata Column for visualization:", 
                  choices = names(read.csv("test.csv")), 
                  selected = names(read.csv("test.csv"))[25]),
# KEGG input selection 
  conditionalPanel(
    condition = "input.heatmap_type == 'KEGG'",
    sliderInput("module_completeness_threshold", "KEGG Module Completeness Threshold for Presence:",
                min = 0, max = 1, value = 0.5, step = 0.01),
  helpText("KEGG Module Completeness represents the completeness of specfic module based on  KO gene presence."),
  helpText("Values below this threshold will be colored as black(original numeric values are not changed)."),
  helpText("Carefully select the threshold for KEGG Module Completeness considering genome characteristics."),

    sliderInput("kegg_cpu_count", "Number of CPUs for KEGG analysis:",
                min = 1, max = parallel::detectCores(), value = 1, step = 1)
  ),

      actionButton(
        inputId = "generate_heatmap",
        label = "Generate Heatmap",
        class = "btn-generate btn-lg btn-block",
        onclick = "Shiny.setInputValue('switch_to_heatmap', true, {priority: 'event'});"
      ),
      div(id = "loading_spinner", class = "spinner-container",
          div(class = "spinner"),
          p("Generating heatmap... Please wait.", style = "color: #007bff; margin-top: 10px;")
      ),  width = 3
    ),                            #new 
    mainPanel(
      conditionalPanel(
        condition = "output.heatmapGenerated",
        InteractiveComplexHeatmapOutput("heatmap", width1 = 1000, height1=750),
                                                 tags$div(
              style = "margin-top: 20px; padding: 10px; background-color: #f0f0f0; border-radius: 5px;",

              h4("How to use this heatmap:"),
              tags$ul(
                tags$li(
                  HTML("Drag cells above heatmap to view detailed gene information including <span style='color: #e74c3c; font-weight: bold;'>Gene IDs</span>.")
                ),
                tags$li(
                  HTML("<span style='color: #e74c3c; font-weight: bold;'>Gene IDs in the table below:</span> Representative gene IDs from gene families defined by COMPARATIVE_ANNOTATION.")
                ),
                tags$li(
                  HTML("All of gene sequecnes of DNA and amino acid in a gene family could be retrieved in <span style='color: #e74c3c; font-weight: bold;'>Sequence Family Finder</span> tab with Gene IDs.")
                ),
                tags$li("Copy interested Gene IDs and utilize it in Sequence Family Finder and Gene Tree Generator."),
                tags$li("Use the toolbar above the heatmap for additional options.")
              ),
                tags$div(
                  style = "margin-top: 10px;",
                  actionButton("go_to_sequence_finder", "Go to Sequence Family Finder", 
                  class = "btn btn-info",  # 파란색 버튼
                  icon = icon("search"))
                )
                                                 ),
                    conditionalPanel(
  condition = "input.heatmap_type == 'KEGG'",
  h4("Selected Module Information"),
  DTOutput("kegg_selected_data"),
  h4("Full KO Gene Table"),
  DTOutput("kegg_full_ko_table")
),
        conditionalPanel(
          condition = "input.heatmap_type != 'KEGG'",
          DTOutput("selected_data")
        ),
        #DTOutput("selected_data")
                downloadButton('downloadData', 'Download Selected Data'),  # 버튼 텍스트 수정

      ),
      conditionalPanel(
        condition = "!output.heatmapGenerated",
        h3("Welcome to metaFun INTERACTIVE_ANNOTATOR viewer"),
        p(HTML("This tool allows you to <span style='font-weight: bold; color: #e74c3c;'>visualize and analyze gene data</span> in species genomes and <span style='font-weight: bold; color: #e74c3c;'>draw phylogenetic trees</span>.")),
        p(HTML("To get started, select <span style='font-weight: bold;'>one of the functional datasets</span> and a <span style='font-weight: bold;'>metadata column</span> for visualization, then click <span style='color: #3498db; font-weight: bold;'>'Generate Heatmap'</span> button on the left sidebar.")),
        p(HTML("Once the heatmap is generated, you can drag the heatmap area to identify detailed information of genes."))
      )
    )
    )
  #)
),

      tabPanel("Data for heatmap", 
            sidebarLayout(
        sidebarPanel(
           h4("Heatmap Settings"),
      selectInput("heatmap_type", "Select Heatmap Type:",
                  choices = c("CARD", "dbCAN", "KEGG", "VFDB","ANI")),
      conditionalPanel(
        condition = "input.heatmap_type != 'KEGG' && input.heatmap_type != 'ANI'",
        selectInput("data_type", "Select Data Type:",
                    choices = c("Gene presence/absence", "Gene count"))
      ),
      selectInput("meta_col", "Metadata Column for visualization:", 
                  choices = names(read.csv("test.csv")), 
                  selected = names(read.csv("test.csv"))[25]),
      actionButton(
        inputId = "generate_heatmap",
        label = "Generate Heatmap",
        class = "btn-generate btn-lg btn-block",
        onclick = "Shiny.setInputValue('switch_to_heatmap', true, {priority: 'event'});"
      ),
      div(id = "loading_spinner", class = "spinner-container",
          div(class = "spinner"),
          p("Generating heatmap... Please wait.", style = "color: #007bff; margin-top: 10px;")
      ),
        width = 3
        ),
        mainPanel(
        h4("Metadata that you provided"),
        
        DTOutput("metadata_contents"),
        hr(),
        h4("Input Data"),
        DTOutput("input_csv_contents")
        ) # main Panel 
        ) # sidebarLayout
      ),        

      tabPanel("Annotation result table", 
  sidebarLayout(
    sidebarPanel(
      h4("File Selection"),
      selectInput("file_selector", "Select file for annotation result table:", 
                  choices = setNames(csv_files, csv_file_names), 
                  selected = csv_files[1]),
                    width = 3
    ),
    mainPanel(
      DTOutput("contents")
    )
  )
),  # Annotation result table tabPanel 

#      tabPanel("Annotation result table", DTOutput("contents")),
      tabPanel("Genome PCoA",
        div(class = "tall-tab-content",
          uiOutput("pcoa_plot")
        )
      ),
# gene association analysis
  tabPanel("Association  Analyzer",
    sidebarLayout(
      sidebarPanel(
        selectInput("category_column", "Select Metadata Column:", choices = NULL),
        sliderInput("num_cores", "Number of cores to use:", min = 1, max = parallel::detectCores(), value = max(1, parallel::detectCores() - 1), step = 1),
        conditionalPanel(
          condition = "output.is_numeric == true",
          selectInput("y_axis", "Select Y-axis for Volcano Plot:", choices = c("filter.pvalue", "lrt.pvalue"))
        ),
        conditionalPanel(
          condition = "output.is_numeric == false",
          sliderInput("p_value_threshold", "Fisher's p-value Threshold:", min = 0, max = 0.1, value = 0.05, step = 0.001),
          sliderInput("fdr_threshold", "FDR Threshold:", min = 0, max = 1, value = 0.05, step = 0.001)
        ),
  div(
    style = "display: flex; flex-direction: column; gap: 10px;",
    actionButton("update_plot", "Update Plot", class = "btn-primary btn-block"),
    actionButton("go_to_sequence_finder", "Go to Sequence Family Finder", 
                 class = "btn btn-info btn-block", icon = icon("search"))
  ),
  # div(id = "loading_spinner", class = "spinner-border text-primary", role = "status", 
  #     style = "display: none; margin: auto;",
  #     tags$span(class = "sr-only", "Loading...")),
  # width = 3
      ),
      mainPanel(
        verbatimTextOutput("debug_output"),
        conditionalPanel(
          condition = "output.is_numeric == true",
          plotlyOutput("volcano_plot")
        ),
        conditionalPanel(
          condition = "output.is_numeric == false",
          InteractiveComplexHeatmapOutput("gene_pa_heatmap")
        ),
        DTOutput("gene_pa_result_table")
      )
    )
  ),

#sequence family finder 
      tabPanel("Sequence Family Finder",
        sidebarLayout(
          sidebarPanel(
            # conditionalPanel(
            #   condition = "!input.query_header",
            #   h4(HTML("Enter representative sequence header(s) of genes in the text area below and click <span style='color: #3498db; font-weight: bold;'>Search</span>."), 
            #   style = "color: #e74c3c;")
            #   ),
            div(
              style = "padding-bottom: 5px; border-bottom: 1px solid #e3e3e3;",
              textAreaInput("query_header", "Enter sequence header(s):",
                  placeholder = "Enter multiple headers separated by space or semicolon"),
              actionButton("search_sequence", "Search", class = "btn-primary")
            ),
      
            div(
              style = "padding-top: 5px; padding-bottom: 5px; border-bottom: 1px solid #e3e3e3;",
              actionButton("draw_tree", "Draw Phylogenetic Tree", class = "btn-primary")
              #verbatimTextOutput("tree_status"),
              #plotOutput("phylogenetic_tree")
            ),
            div(
              style = "padding-top: 5px;",
              h4("Save search results of sequences and metadata of interest"),
              textInput("save_basename", "Enter base name for files:"),
              actionButton("save_to_server", "Save to Server", class = "btn-success"),
              uiOutput("save_notification")
            ),
            width = 3
          ),
          mainPanel(
            conditionalPanel(
            condition = "input.query_header && input.query_header.trim().length > 0",
            h4("Gene Family Cluster"),
            DTOutput("family_cluster"),
            h4("Protein Sequences (FAA)"),
            div(style = "height: 300px; overflow-y: scroll;",
                verbatimTextOutput("faa_sequences")
            ),
            h4("Nucleotide Sequences (FFN)"),
            div(style = "height: 300px; overflow-y: scroll;",
                verbatimTextOutput("ffn_sequences")
            ),
            h4("Metadata"),
            DTOutput("sequence_metadata"),
            downloadButton("download_faa", "Download FAA"),
            downloadButton("download_ffn", "Download FFN"),
            downloadButton("download_metadata", "Download Metadata")
          ),
            conditionalPanel(
    condition = "!input.query_header || input.query_header.trim().length === 0",

    h4(HTML("Please enter the sequence headers of gene families in the <span style='color: #3498db; font-weight: bold;'>'Enter sequence header(s):'</span> box at the left side panel.<br><br>" )),

    h5(HTML("You can identify sequence header(s) in one of  the following tabs: <span style='color: #20c997; font-weight: bold;'>'Heatmap'</span>, <span style='color: #20c997; font-weight: bold;'>'Data for heatmap'</span>, or <span style='color: #20c997; font-weight: bold;'>'Annotation result table'</span>.<br><br>" )),
    h5(HTML("<span style='color: #3498db; font-weight: bold;'>'Search'</span> button can retrieve all  DNA and amino acid sequences and metadata of entered gene families.<br><br>" )),
    h5(HTML("By clicking <span style='color: #3498db; font-weight: bold;'>'Draw Phylogenetic Tree'</span>  button,  the tab is automatically converted to <span style='color: #20c997; font-weight: bold;'>'Gene Tree Generator'</span> tab.<br><br>" )),
    h5(HTML("To utilize <span style='color: #20c997; font-weight: bold;'>'Gene Tree Generator'</span> tab, <span style='color: #e74c3c; font-weight: bold;'>You should have to search sequences first with headers in this tab</span>.<br><br>" )),
    h5(HTML("In the <span style='color: #20c997; font-weight: bold;'>'Gene Tree Generator'</span> tab, you could draw phylogenetic tree with gene sequences of DNA or amino acid with metadata of your interest.<br><br>" )),
    #h4(HTML("By clicking <span style='color: #3498db; font-weight: bold;'>'Save to Server'</span>  button,  You could draw DNA or amino acieds trees interactively with metadata of your own interest." )),
    h5(HTML("You can also retrieve genomic sequences and metadata. Please write down base name of files and click <span style='color: #3498db; font-weight: bold;'>'Save to Server'</span>  button.<br><br>" )),
    #h3(HTML("To get started, select <span style='font-weight: bold;'>one of the functional datasets</span> and a <span style='font-weight: bold;'>metadata column</span> for visualization, then click <span style='color: #3498db; font-weight: bold;'>'Generate Heatmap'</span> button on the left sidebar.")),
    #h3(HTML("Once the heatmap is generated, you can drag the heatmap area to identify detailed information of genes."))
          )
          ))

        ),
      
      tabPanel("Gene Tree Generator",
        conditionalPanel(
          condition = "!input.draw_tree",
          h4(HTML("Select genes in <span style='color: #20c997; font-weight: bold;'>'Sequence Family Finder'</span>  tab. <br> <br>elect gene families of your interest, and search the sequences by clicking <span style='color: #e74c3c; font-weight: bold;'>'Search'</span> button and  click the <span style='color: #e74c3c; font-weight: bold;'>'Draw Phylogenetic Tree'</span> button."))
        ),
        conditionalPanel(
          condition = "input.draw_tree",
          sidebarLayout(
            sidebarPanel(
              selectInput("seq_type", "Select Sequence Type:",
                          choices = c("Protein (FAA)" = "faa", "Nucleotide (FFN)" = "ffn")),
              selectInput("color_column", "Select column for coloring:", choices = NULL),
              textInput("file_base_name", "Type basename for output files:"),
              sliderInput("thread_count", "Number of Threads:",
                          min = 1, max = 1, value = 1, step = 1),
              actionButton("generate_tree", "Generate Tree", class = "btn-primary"),
              width = 3
            ),
            mainPanel(
              div(style = "border: 1px solid #ddd; padding: 15px; background-color: #f9f9f9;",
                  h3("Interactive Phylogenetic Tree", align = "center"),
                  uiOutput("dynamic_tree_output")
              ),
              verbatimTextOutput("gene_tree_info"),
              verbatimTextOutput("file_info"),
              h3("Metadata of Selected Sequences", align = "center"),
              DTOutput("selected_metadata")
            )
          )
      )
    )
  )
)



# 서버 로직
server <- function(input, output, session) {
# start page 


observeEvent(input$go_to_sequence_finder, {
  updateTabsetPanel(session, "main_tabs", selected = "Sequence Family Finder")
})

#   shinyjs::delay(400, updateTabsetPanel(session, "main_tabs", selected = "Heatmap"))

#######
# shared side bar layout in server ui 

    observeEvent(input$switch_to_heatmap, {
    updateTabsetPanel(session, "main_tabs", selected = "Heatmap")
  })
  
  # shared sidebar layout in server ui
#######

# start 
  app_state <- reactiveValues(initialized = FALSE)  
  observe({
    if (!app_state$initialized) {
      updateTabsetPanel(session, "main_tabs", selected = "Heatmap")
      app_state$initialized <- TRUE
    }
  })


# gene pa , association analyzer
  gene_pa_data <- reactiveVal()
  
  observe({
    d <- load_data()
    gene_pa_data(d)
    updateSelectInput(session, "category_column", choices = colnames(d$metadata))
  })
  
  output$is_numeric <- reactive({
    req(gene_pa_data(), input$category_column)
    is.numeric(gene_pa_data()$metadata[[input$category_column]])
  })
  
  outputOptions(output, "is_numeric", suspendWhenHidden = FALSE)
  
gene_pa_result <- eventReactive(input$update_plot, {

# add progress bar 
  # withProgress(message = 'Calculation in progress',
  #              detail = 'This may take a while...', value = 0, {


  req(gene_pa_data())
  d <- gene_pa_data()
  gene_pa <- d$gene_pa
  metadata <- d$metadata
  selected_category <- input$category_column
  category <- metadata[[selected_category]]
  
  if (is.numeric(category)) {
    # 숫자형 데이터: pyseer 실행
    phenotype_data <- data.frame(sample = rownames(metadata), phenotype = category)
    phenotype_file <- tempfile(fileext = ".tsv")
    write.table(phenotype_data, phenotype_file, sep = "\t", row.names = FALSE, quote = FALSE)
    
    gene_pa_file <- "gene_presence_absence.Rtab"
    
    pyseer_result <- run_pyseer(phenotype_file, gene_pa_file, input$num_cores, selected_category)
    
    # 임시 파일 삭제
    unlink(phenotype_file)
    
    list(result_table = pyseer_result, is_numeric = TRUE)
  } else {
    # 카테고리형 데이터: Fisher's exact test 실행
    unique_categories <- unique(category)
    num_cores_to_use <- input$num_cores
    p_value_threshold <- input$p_value_threshold

    results <- lapply(unique_categories, function(cat_value) {
      process_category(cat_value, gene_pa, category, num_cores_to_use, p_value_threshold)
    })

    combined_result_table <- do.call(rbind, results)

    if (nrow(combined_result_table) > 0) {
      combined_result_table$fdr <- p.adjust(combined_result_table$p_value, method = "fdr")
      filtered_result_table <- combined_result_table %>%
        filter(fdr <= input$fdr_threshold) %>%
        arrange(p_value)
    } else {
      filtered_result_table <- combined_result_table
    }
    
    list(gene_pa = gene_pa, category = category, result_table = filtered_result_table, is_numeric = FALSE)
  }
  #     incProgress(1)
  #     #added this 
  #     return(gene_pa_result)
  # })
})

observe({
  req(gene_pa_result())
  res <- gene_pa_result()
  
  if (res$is_numeric) {
    # pyseer 결과 표시
    output$volcano_plot <- renderPlotly({
      plot_data <- res$result_table
      y_col <- input$y_axis
      plot_data$neg_log10_p <- -log10(plot_data[[y_col]])

      p <- plot_ly(plot_data, x = ~beta, y = ~neg_log10_p, 
                   text = ~paste("Variant:", variant, 
                                 "<br>Beta:", beta, 
                                 "<br>P-value:", plot_data[[y_col]], 
                                 "<br>AF:", af),
                   type = 'scatter', mode = 'markers',
                   marker = list(size = ~af*10, opacity = 0.6),
                   hoverinfo = 'text') %>%
        layout(title = 'Volcano Plot',
               xaxis = list(title = 'Beta'),
               yaxis = list(title = paste('-log10(', y_col, ')')))

      p
    })

    output$gene_pa_result_table <- renderDT({
      datatable(res$result_table, options = list(pageLength = 10, scrollX = TRUE))
    })
  } else {
    # Fisher's exact test 결과 및 heatmap 표시
    if (!is.null(res) && nrow(res$result_table) > 0) {
      significant_genes <- unique(res$result_table$gene_id)
      gene_pa_filtered <- res$gene_pa[rownames(res$gene_pa) %in% significant_genes, , drop = FALSE]
      
      ht <- Heatmap(as.matrix(gene_pa_filtered),
                    name = "Gene Presence/Absence",
                    col = c("white", "red"),
                    show_row_names = FALSE,
                    show_column_names = FALSE,
                    column_split = res$category,
                    top_annotation = HeatmapAnnotation(
                      category = res$category,
                      Average_value = anno_barplot(colMeans(gene_pa_filtered))
                    ),
                    left_annotation = rowAnnotation(
                      Module_averages = anno_barplot(rowMeans(gene_pa_filtered))
                    )
      )
      makeInteractiveComplexHeatmap(input, output, session, ht, "gene_pa_heatmap")
      
      output$gene_pa_result_table <- renderDT({
        datatable(res$result_table, options = list(pageLength = 10, scrollX = TRUE))
      })
    } else {
      output$gene_pa_heatmap <- renderPlot({
        plot.new()
        text(0.5, 0.5, "No significant genes found", cex = 1.5)
      })
      output$gene_pa_result_table <- renderDT({
        datatable(data.frame(Message = "No genes passed the thresholds"), options = list(dom = 't'))
      })
    }
  }
})

  # Sequence Family Finder로 이동하는 버튼 로직
  observeEvent(input$go_to_sequence_finder, {
    updateTabsetPanel(session, "main_tabs", selected = "Sequence Family Finder")
  })
# gene pa , association analyzer




    log_file <- tempfile(pattern = "tree_generation_log_", fileext = ".txt")
 
    max_threads <- reactiveVal(1)
#count available cpus 
  observe({
    # parallel cpu  number check 
    available_cores <- parallel::detectCores()
    max_threads(available_cores)
    
    # set maximum value of cpu slide 
    updateSliderInput(session, "thread_count",
                      max = available_cores,
                      value = min(available_cores, input$thread_count))
  })


  observe({
  
    if(input$main_tabs %in% c("Genome PCoA", "Sequence Family Finder", "Gene Tree Generator")) {
      shinyjs::hide("sidebar_column")
      shinyjs::removeCssClass("main_column", "col-sm-9")
      shinyjs::addCssClass("main_column", "col-sm-12")
    } else {
      shinyjs::show("sidebar_column")
      shinyjs::removeCssClass("main_column", "col-sm-12")
      shinyjs::addCssClass("main_column", "col-sm-9")
    }
  })  
  # Show csv file 
  observeEvent(input$file_selector, {
    #updateTabsetPanel(session, "main_tabs", selected = "Annotation result table")    
    req(input$file_selector)
    df <- read.csv(input$file_selector, header = TRUE, check.names = FALSE)
    output$contents <- renderDT({
      datatable(df, options = list(pageLength = 10, scrollX = TRUE))
    })
  })
  input_file <- reactive({
    if (input$heatmap_type == "CARD") {
      ifelse(input$data_type == "Gene presence/absence", "gene_PA_CARD_added.csv", "gene_count_CARD_added.csv")
    } else if (input$heatmap_type == "dbCAN") {
      ifelse(input$data_type == "Gene presence/absence", "dbcan_hmmerfamily_PA_matrix.csv", "dbcan_hmmerfamily_count_matrix.csv")
    } else if (input$heatmap_type == "KEGG") {
      "ko_matrix.csv"
    } else if (input$heatmap_type == "VFDB") {
      ifelse(input$data_type == "Gene presence/absence", "gene_PA_VFDB_added.csv", "gene_count_VFDB_added.csv")
    }
  })
  
##### server logic 
# save sequences to server (sequence family finder )
observeEvent(input$save_to_server, {
  req(search_results(), input$save_basename)
  
  tryCatch({
    # 저장할 디렉토리 생성
    save_dir <- file.path(getwd(), "saved_sequences")
    dir.create(save_dir, showWarnings = FALSE, recursive = TRUE)
    
    # FAA 시퀀스 저장
    faa_file <- file.path(save_dir, paste0(input$save_basename, "_faa.fasta"))
    writeLines(paste(sapply(names(search_results()$faa), function(name) {
      paste0(">", name, "\n", search_results()$faa[[name]])
    }), collapse = "\n"), faa_file)
    
    # FFN 시퀀스 저장
    ffn_file <- file.path(save_dir, paste0(input$save_basename, "_ffn.fasta"))
    writeLines(paste(sapply(names(search_results()$ffn), function(name) {
      paste0(">", name, "\n", search_results()$ffn[[name]])
    }), collapse = "\n"), ffn_file)
    
    # 메타데이터 저장
    metadata_file <- file.path(save_dir, paste0(input$save_basename, "_metadata.csv"))
    write.csv(search_results()$metadata, metadata_file, row.names = FALSE)
    
    output$save_notification <- renderUI({
      div(
        style = "color: green; margin-top: 10px;",
        "Files saved successfully:",
        tags$ul(
          tags$li(faa_file),
          tags$li(ffn_file),
          tags$li(metadata_file)
        )
      )
    })
  }, error = function(e) {
    output$save_notification <- renderUI({
      div(style = "color: red; margin-top: 10px;", paste("Error saving files:", e$message))
    })
  })
})
# save sequences to server (sequence family finder )
##### server logic 

  observeEvent(input$draw_tree, {
    req(search_results())
    updateTabsetPanel(session, "main_tabs", selected = "Gene Tree Generator")
    
    metadata <- search_results()$metadata
    
    output$selected_metadata <- renderDT({
      datatable(metadata,
                options = list(pageLength = 5, scrollX = TRUE, scrollY = "500px"))
    })
    
    updateSelectInput(session, "color_column",
                      choices = names(metadata),
                      selected = names(metadata)[5])
  })

file_base_name <- reactiveVal("")



  observeEvent(input$color_column, {
    req(search_results(), input$color_column)
    
    metadata <- search_results()$metadata
    representative_id <- sub("gnl\\|Prokka\\|", "", metadata$representative_id[1])
    new_basename <- paste0(input$color_column, "_", representative_id)

      file_base_name(new_basename)
    updateTextInput(session, "file_base_name", value = new_basename)
  })
  
  observeEvent(input$file_base_name, {
  file_base_name(input$file_base_name)
})
  # click heatmap -->  select heatmap 
  observeEvent(input$generate_heatmap, {
    updateTabsetPanel(session, "main_tabs", selected = "Heatmap")

  })
  
  # Metadata (test.csv) 표시
    output$metadata_contents <- renderDT({
      req(file.exists("test.csv"))
      tryCatch({
        df <- read.csv("test.csv", header = TRUE, check.names = FALSE)
        datatable(df, options = list(pageLength = 5, scrollX = TRUE))
      }, error = function(e) {
        message("Error reading metadata CSV: ", e$message)
        return(NULL)
      })
    })

# show csv file used for heatmap 
    output$input_csv_contents <- renderDT({
      req(input_file())
      tryCatch({
        df <- read.csv(input_file(), header = TRUE, check.names = FALSE)
        datatable(df, options = list(pageLength = 10, scrollX = TRUE))
      }, error = function(e) {
        message("Error reading input CSV: ", e$message)
        return(NULL)
      })
    })

  heatmap_data <- eventReactive(input$generate_heatmap, {
    req(input$heatmap_type)  # 필수 입력값 확인
    metadata <- read.csv("test.csv", header = TRUE, check.names = FALSE)
    meta_col_index <- which(names(metadata) == input$meta_col)
    
    result <- tryCatch({
      if (input$heatmap_type == "CARD") {
        input_file <- ifelse(input$data_type == "Gene presence/absence", "gene_PA_CARD_added.csv", "gene_count_CARD_added.csv")
        create_card_heatmap(input_file, "test.csv", meta_col_index)#input$meta_col)
      } else if (input$heatmap_type == "dbCAN") {
        input_file <- ifelse(input$data_type == "Gene presence/absence", "dbcan_hmmerfamily_PA_matrix.csv", "dbcan_hmmerfamily_count_matrix.csv")
        create_dbcan_heatmap(input_file, "dbcan_geneID_HMMER_count_gene_count.csv","test.csv", meta_col_index)#input$meta_col)
      } else if (input$heatmap_type == "KEGG") {
        create_kegg_heatmap("ko_matrix.csv", "test.csv", meta_col_index,
        module_completeness_threshold = input$module_completeness_threshold,
        cpu_count = input$kegg_cpu_count)#input$meta_col, 0.5)
      } else if (input$heatmap_type == "VFDB") {
        input_file <- ifelse(input$data_type == "Gene presence/absence", "gene_PA_VFDB_added.csv", "gene_count_VFDB_added.csv")
        create_vfdb_heatmap(input_file, "test.csv", meta_col_index)#input$meta_col)
      } else if (input$heatmap_type == "ANI") {
        create_ani_heatmap("skani_fullmatrix", "test.csv",meta_col_index)# input$meta_col)
      }
    }, error = function(e) {
        message("Error: ", e$message)
      # 에러 발생 시 NULL 반환 또는 기본 heatmap 생성
    })
    result
  })



heatmap_result <- reactiveVal(NULL)

output$heatmapGenerated <- reactive({
  !is.null(heatmap_result())
})
outputOptions(output, "heatmapGenerated", suspendWhenHidden = FALSE)


  observeEvent(input$generate_heatmap, {
    # 버튼 비활성화 및 로딩 메시지 표시
    shinyjs::disable("generate_heatmap")
    shinyjs::show("loading_spinner")

    #shinyjs::show("loading_message")
    
    # Switch tab
    updateTabsetPanel(session, "main_tabs", selected = "Heatmap")
    


    # heatmap 생성 로직
    tryCatch({
    result <- heatmap_data()
    heatmap_result(result)    
    heatmap_result <- heatmap_data()

# brush action added heatmap 
      if (input$heatmap_type == "CARD") {
      makeInteractiveComplexHeatmap(input, output, session, heatmap_result$plot, "heatmap",
        brush_action = function(df, input, output, session) {
            print("Gene info structure:")
            print(str(heatmap_result$gene_info))

          row_index <- unique(unlist(df$row_index))
          col_index <- unique(unlist(df$column_index))

          if(length(row_index) == 0 || length(col_index) == 0) {
            output$selected_data <- renderDT({ 
              datatable(data.frame(Message = "No data selected"), 
                        options = list(pageLength = 10, scrollX = TRUE, scrollY = "800px"))
            })
            return()
          }
          selected_data <- heatmap_result$data[row_index, col_index, drop = FALSE]
          card_short_name_info <- heatmap_result$data$CARD_Short_Name[row_index]
            print("Selected data structure:")
            print(str(selected_data))

          #gene_info <- heatmap_result$data[row_index, c("Resistance Mechanism", "CARD Short Name", "Drug Class"), drop = FALSE]
  gene_info <- heatmap_result$gene_info %>%
    dplyr::filter(CARD_Short_Name %in% card_short_name_info) %>%
    dplyr::group_by(CARD_Short_Name) %>%
    dplyr::summarise(
      `Gene IDs` = paste(Gene, collapse = "; "),#,
      Resistance_Mechanism=Resistance_Mechanism,
      Drug_Class=Drug_Class
      #Resistance_Mechanism = first(Resistance_Mechanism),
      #Drug_Class = first(Drug_Class)
    )
    print("gene_info")
    print(gene_info)

               print("Selected data structure:")
            print(str(selected_data))
            print(selected_data)
      result_table <- selected_data %>%
       dplyr::mutate(CARD_Short_Name = card_short_name_info) %>%
        #dplyr::mutate(Gene = rownames(selected_data)) %>%
        dplyr::left_join(gene_info, by = "CARD_Short_Name") %>%
        dplyr::select(`Gene IDs`, CARD_Short_Name, Resistance_Mechanism, Drug_Class, dplyr::everything())
      #Resistance_Mechanism
          output$selected_data <- renderDT({
                        datatable(result_table, options = list(
              pageLength = 10,
              lengthMenu = list(c(10, 25, 50, 100, -1), c('10', '25', '50', '100', 'All')),
                   scrollX = TRUE,
      scrollY = "800px",
      select = list(style = 'multi', items = 'cell'),
      dom = 'Blfrtip',
      buttons = list(
        list(
          extend = 'copy',
          text = 'Copy Selected',
          action = JS("
            function (e, dt, button, config) {
              var selectedIndexes = dt.cells({ selected: true }).indexes();
              var selectedRowIndexes = $.unique(selectedIndexes.pluck('row').toArray());
              var selectedColumnIndexes = $.unique(selectedIndexes.pluck('column').toArray());
              
              var headers = selectedColumnIndexes.map(function(index) {
                return dt.column(index).header().textContent;
              });
              
              var copyData = 'Row\\t' + headers.join('\\t') + '\\n';
              
              selectedRowIndexes.forEach(function(rowIndex) {
//                var rowData = [rowIndex + 1];
                var rowData = [];

                selectedColumnIndexes.forEach(function(colIndex) {
                  rowData.push(dt.cell(rowIndex, colIndex).data());
                });
                copyData += rowData.join('\\t') + '\\n';
              });
              
              var textarea = document.createElement('textarea');
              textarea.value = copyData;
              document.body.appendChild(textarea);
              textarea.select();
              document.execCommand('copy');
              document.body.removeChild(textarea);
              
              dt.buttons.info('Copied ' + selectedRowIndexes.length + ' rows to clipboard', '', 3000);
            }
          ")
        ),
        list(
          extend = 'copy',
          text = 'Copy All'
        ),
        'selectAll',
        'selectNone',
        'selectCells',
        'selectColumns',
        'selectRows'
      )
    ),
    extensions = c('Buttons', 'Select'),
    selection = 'none'
  ) %>%
  formatStyle(columns = names(result_table),
              backgroundColor = 'white',
              cursor = 'pointer',
              `white-space` = 'normal',
              `word-wrap` = 'break-word')
})
        }
      )

    } else if (input$heatmap_type == "dbCAN") {
      makeInteractiveComplexHeatmap(input, output, session, heatmap_result$plot, "heatmap",
        brush_action = function(df, input, output, session) {
          row_index <- unique(unlist(df$row_index))
          col_index <- unique(unlist(df$column_index))
            print(paste("Row index:", paste(row_index, collapse=", ")))
            print(paste("Column index:", paste(col_index, collapse=", ")))

          selected_data <- heatmap_result$data[row_index, col_index, drop = FALSE]
          hmmer_info <- heatmap_result$data$HMMER[row_index]
            if(length(hmmer_info) == 0) {
              output$selected_data <- renderDT({ datatable(data.frame(Message = "No data selected")) })
              return()      
              }
          gene_info <- heatmap_result$gene_data %>%
            dplyr::filter(HMMER %in% hmmer_info) %>%
            dplyr::group_by(HMMER) %>%
            dplyr::summarise(
              `Gene IDs` = paste(Gene, collapse = "; ")
            )
            print(str(selected_data))
            print(selected_data)

            result_table <- selected_data %>%
              dplyr::mutate(HMMER = hmmer_info) %>%
              dplyr::left_join(gene_info, by = "HMMER") %>%
              dplyr::select(HMMER, `Gene IDs`, dplyr::everything())
          
          output$selected_data <- renderDT({
            datatable(result_table, options = list(
              pageLength = 10,
              lengthMenu = list(c(10, 25, 50, 100, -1), c('10', '25', '50', '100', 'All')),
                   scrollX = TRUE,
      scrollY = "800px",
      select = list(style = 'multi', items = 'cell'),
      dom = 'Blfrtip',
      buttons = list(
        list(
          extend = 'copy',
          text = 'Copy Selected',
          action = JS("
            function (e, dt, button, config) {
              var selectedIndexes = dt.cells({ selected: true }).indexes();
              var selectedRowIndexes = $.unique(selectedIndexes.pluck('row').toArray());
              var selectedColumnIndexes = $.unique(selectedIndexes.pluck('column').toArray());
              
              var headers = selectedColumnIndexes.map(function(index) {
                return dt.column(index).header().textContent;
              });
              
              var copyData = 'Row\\t' + headers.join('\\t') + '\\n';
              
              selectedRowIndexes.forEach(function(rowIndex) {
//                var rowData = [rowIndex + 1];
                var rowData = [];

                selectedColumnIndexes.forEach(function(colIndex) {
                  rowData.push(dt.cell(rowIndex, colIndex).data());
                });
                copyData += rowData.join('\\t') + '\\n';
              });
              
              var textarea = document.createElement('textarea');
              textarea.value = copyData;
              document.body.appendChild(textarea);
              textarea.select();
              document.execCommand('copy');
              document.body.removeChild(textarea);
              
              dt.buttons.info('Copied ' + selectedRowIndexes.length + ' rows to clipboard', '', 3000);
            }
          ")
        ),
        list(
          extend = 'copy',
          text = 'Copy All'
        ),
        'selectAll',
        'selectNone',
        'selectCells',
        'selectColumns',
        'selectRows'
      )
    ),
    extensions = c('Buttons', 'Select'),
    selection = 'none'
  ) %>%
  formatStyle(columns = names(result_table),
              backgroundColor = 'white',
              cursor = 'pointer',
              `white-space` = 'normal',
              `word-wrap` = 'break-word')
})
}
      )
    } else if (input$heatmap_type == "KEGG") {
      makeInteractiveComplexHeatmap(input, output, session, heatmap_result$plot, "heatmap",
        
        brush_action = function(df, input, output, session) {
          row_index <- unique(unlist(df$row_index))
          col_index <- unique(unlist(df$column_index))


      if(length(row_index) == 0 || length(col_index) == 0) {
#        output$selected_data <- renderDT({ 
        output$kegg_selected_data <- renderDT({ 

          datatable(data.frame(Message = "No data selected"), 
                    options = list(pageLength = 5, scrollX = TRUE, scrollY = "400px"))
        })
      } else {
               selected_data <- heatmap_result$data[row_index, col_index, drop = FALSE]
        
        result_table <- selected_data %>%
          dplyr::mutate(Module = rownames(selected_data)) %>%
          dplyr::left_join(heatmap_result$module_info, by = c("Module" = "Module")) %>%
          dplyr::select(Module, Module_Name, Pathway_Category, Pathway_Class, dplyr::everything())
      
        output$kegg_selected_data <- renderDT({
          datatable(result_table, options = list(pageLength = 5, scrollX = TRUE, scrollY = "400px"))
        })
      }
                output$kegg_full_ko_table <- renderDT({
            #output$full_ko_table <- renderDT({
        datatable(heatmap_result$ko_definition, options = list(pageLength = 10, scrollX = TRUE, scrollY = "400px"))
        }
      )
        })

    } 
    # VFDB
     else if (input$heatmap_type == "VFDB") {
       makeInteractiveComplexHeatmap(input, output, session, heatmap_result$plot, "heatmap",

brush_action = function(df, input, output, session) {
      tryCatch({
        row_index <- unique(unlist(df$row_index))
        col_index <- unique(unlist(df$column_index))
        
        if(length(row_index) == 0 || length(col_index) == 0) {
          output$selected_data <- renderDT({ 
            datatable(data.frame(Message = "Data is not selected"), 
                      options = list(pageLength = 10, scrollX = TRUE, scrollY = "800px"))
          })
          return()
        }

data_col_index <- col_index + 7
# 변환된 인덱스로 데이터 선택
selected_data <- heatmap_result$data[row_index, data_col_index, drop = FALSE]


# heatmap_data <- heatmap_result$data[, numeric_cols]
# selected_data <- heatmap_result$data[row_index, c(metadata_cols, numeric_cols[col_index])]
#     selected_data <- heatmap_result$data[row_index, , drop = FALSE]
#     selected_numeric_cols <- numeric_cols[col_index]



print("Selected row indices:")
print(row_index)
print("Selected column indices:")
print(data_col_index)
print("Row names in data:")
print(rownames(heatmap_result$data)[row_index])
print("Column names in data:")
print(colnames(heatmap_result$data)[data_col_index])


         #selected_data <- heatmap_result$data[row_index, col_index, drop = FALSE]
print("selected_data1:")
print(str(selected_data))
print("heatmap_result$data:")
print(str(heatmap_result$data))
print("heatmap_result$data$VF:")
print(str(heatmap_result$data$VF))

        
# VF contains only VF####, 
vf_ids <- heatmap_result$data$VF[row_index]  # name format  VF1127

print("vf_ids:")
print(vf_ids)
print("selected_data before adding VF_ID:")
print(str(selected_data))

    # matched_rows <- match(rownames(selected_data), rownames(heatmap_result$data[row_index, , drop = FALSE]))
    # vf_ids <- vf_ids[matched_rows]
    # VF_ID 추가
    if (length(vf_ids) != nrow(selected_data)) {
      stop("Mismatch between vf_ids length and selected_data rows")
    }

        # VFID 정규화 함수
        normalize_vfid <- function(vfid) {
          vf_id <- stringr::str_extract(as.character(vfid), "\\(VF\\d+\\)")          
          #vf_id <- stringr::str_extract(vfid, "\\(VF\\d+\\)")
          vf_id <- stringr::str_remove_all(vf_id, "[\\(\\)]")
          return(vf_id)
        }

selected_data <- selected_data %>%
      dplyr::mutate(
        VF_ID = as.character(vf_ids)#,  
        #normalized_VFID = normalize_vfid(vf_ids)  
      )

#print("selected_data after adding VF_ID:")
#print(str(selected_data))
print("look here0")
print("heatmap_result$gene_vf_info:")
print(str(heatmap_result$gene_vf_info))

# gene_info  
print(head( heatmap_result$gene_vf_info))

        gene_info <- heatmap_result$gene_vf_info %>%
          #dplyr::filter(VF_ID %in% selected_data$VFID) %>%
          dplyr::mutate(VF_ID = normalize_vfid(VF_ID)) %>%
          dplyr::filter(VF_ID %in% selected_data$VF_ID) %>%
          dplyr::group_by(VF_ID) %>%
          dplyr::summarise(
            `Gene IDs` = paste(Gene, collapse = "; "),
            gene_description = paste(unique(gene_description), collapse = "; "),
            VFG_ID = paste(unique(VFG_ID), collapse = "; "),
            organism = paste(unique(organism), collapse = "; ")
          ) 

print("selected_data2:")
print(str(selected_data))

     tmp<-   selected_data %>%
  dplyr::left_join(gene_info, by = "VF_ID") 
print("colnames(tmp):")
print(colnames(tmp))

        result_table <- selected_data %>%
          dplyr::left_join(gene_info, by = "VF_ID")  %>% 
             dplyr::select(VF_ID, VFG_ID, gene_description,`Gene IDs`,  organism, dplyr::everything()) #%>%

print("colnames(result_table):")
print(colnames(result_table))
        print("result_table:")
        print(str(result_table))
        
        output$downloadData <- downloadHandler(
          filename = function() {
            paste0("VFDB_selected_data_", format(Sys.time(), "%Y%m%d_%H%M%S"), ".csv")
          },
          content = function(file) {
            write.csv(result_table, file, row.names = FALSE)
          }
        )

        output$selected_data <- renderDT({
          datatable(result_table, 
          extensions = c('Buttons', 'Select'),
          options = list(
            pageLength = 10,
            lengthMenu = list(c(10, 25, 50, 100, -1), c('10', '25', '50', '100', 'All')),
            scrollX = TRUE,
            scrollY = "800px",
select = list(
          style = 'multi',
        items = c('row', 'cell')  
        ),
            dom = 'lfrtip', # remove B : Button 
buttons = list(
  list(
    extend = 'copy',
    text = 'Copy Selected'
  ),
  'selectAll',
  'selectNone', 
  'selectColumns'
  )
      ),
    selection = list(
      mode = 'multiple',  # 다중 선택 가능
      target = 'cell'  # 행과 셀 선택 가능
    )
        ) %>%
        formatStyle(columns = names(result_table),
                    backgroundColor = 'white',
                    cursor = 'pointer',
                    `white-space` = 'normal',
                    `word-wrap` = 'break-word')
        })
      }, error = function(e) {
        print(paste("Error in join or select:", e$message))
        output$selected_data <- renderDT({ 
          datatable(data.frame(Error = paste("오류 발생:", e$message)), 
                    options = list(pageLength = 10, scrollX = TRUE, scrollY = "800px"))
        })
      })
    }
  )

    } else if (input$heatmap_type == "ANI") {
      makeInteractiveComplexHeatmap(input, output, session, result$plot, "heatmap",
        brush_action = function(df, input, output, session) {
          row_index <- unique(unlist(df$row_index))
          col_index <- unique(unlist(df$column_index))
          selected_data <- result$data[row_index, col_index, drop = FALSE]
          
          result_table <- selected_data  # 
          output$selected_data <- renderDT({
            datatable(result_table, options = list(pageLength = 10, scrollX = TRUE, scrollY = "800px"))
          })
        })
    }
      
  }, error = function(e) {
    output$heatmap <- renderPlot({
      plot.new()
      text(0.5, 0.5, "Error generating heatmap. Please check your inputs.")
    })
  }, finally = {
    shinyjs::enable("generate_heatmap")
    shinyjs::hide("loading_spinner")
  })
})



observeEvent(input$main_tabs, {
  if(input$main_tabs == "Genome PCoA") {
    shinyjs::delay(500, {
      shinyjs::runjs("
        var iframe = document.querySelector('#pcoa-iframe');
        if (iframe && iframe.contentWindow) {
          // iframe 크기 조정
          var container = document.querySelector('.tall-tab-content');
          iframe.style.height = container.offsetHeight + 'px';
          iframe.style.width = container.offsetWidth + 'px';
          
          // iframe 내부의 선택 요소 숨기기
          var selectorDiv = iframe.contentWindow.document.querySelector('.selector-div');
          if (selectorDiv) {
            selectorDiv.style.display = 'none';
          }
        }
      ")
    })
  }
})

# direct load html 


output$pcoa_plot <- renderUI({
  div(
    class = "tall-tab-content",
    tags$iframe(
      src = "pcoa_plot_interactive.html", 
      style = "width:100%; height:100%; border:none;",
      id = "pcoa-iframe"
    )
  )
})

######################
#### sequence family finder 
  search_results <- reactiveVal()

  observeEvent(input$search_sequence, {
    req(input$query_header)
    #cleaned_input <- gsub("\\s+", " ", input$query_header)
    cleaned_input <- gsub("\r\n|\n|\r", "\n", input$query_header)

    queries <- unlist(strsplit(cleaned_input, "[\\s;,\n]+"))
    queries <- unique(trimws(queries[nzchar(queries)]))

    results <- lapply(queries, function(query) {
      sequence_family_finder(query, "sequences.h5", "test.csv")
    })    
    combined_results <- list(
      family = do.call(rbind, lapply(results, `[[`, "family")),
      faa = unlist(lapply(results, `[[`, "faa"), recursive = FALSE),
      ffn = unlist(lapply(results, `[[`, "ffn"), recursive = FALSE),
      metadata = do.call(rbind, lapply(results, `[[`, "metadata"))
    )
    
    search_results(combined_results)
  })

  output$family_cluster <- renderDT({
    req(search_results())
    datatable(search_results()$family)
  })

  output$faa_sequences <- renderText({
    req(search_results())
    faa_seqs <- search_results()$faa
    if (length(faa_seqs) > 0) {
      paste(sapply(names(faa_seqs), function(name) {
        paste0(">", name, "\n", faa_seqs[[name]])
      }), collapse = "\n\n")
    } else {
      "No FAA sequences found."
    }
  })

  output$ffn_sequences <- renderText({
    req(search_results())
    ffn_seqs <- search_results()$ffn    
    if (length(ffn_seqs) > 0) {
      paste(sapply(names(ffn_seqs), function(name) {
        paste0(">", name, "\n", ffn_seqs[[name]])
      }), collapse = "\n\n")
    } else {
      "No FNA sequences found."
    }
  })

  output$sequence_metadata <- renderDT({
    req(search_results())
    datatable(search_results()$metadata)
  })
# sequence family finder
####################

###################
#draw tree
  observeEvent(input$generate_tree, {
    req(search_results(), input$seq_type, input$color_column)

    withProgress(message = 'Generating Gene Tree', value = 0, {
      tryCatch({
        sequences <- if(input$seq_type == "faa") search_results()$faa else search_results()$ffn
        if(length(sequences) == 0) {
          stop("No sequences available for tree construction")
        }
#          cat("Sequence reading\n", file = log_file)

        incProgress(0.2, detail = "Preparing sequences")
        
        fasta_string <- paste(sapply(names(sequences), function(name) {
          paste0(">", name, "\n", sequences[[name]])
        }), collapse = "\n")        
# switch tmp file mode of action 
#        temp_file <- tempfile(fileext = ".fasta")
temp_dir <- file.path(getwd(), "temp")
dir.create(temp_dir, showWarnings = FALSE, recursive = TRUE)
temp_file <- file.path(temp_dir, paste0("temp_", format(Sys.time(), "%Y%m%d_%H%M%S"), ".fasta"))

        writeLines(fasta_string, temp_file)

        output_dir <- if(input$seq_type == "faa") {
          file.path(getwd(), "Amino_acid_tree")
        } else {
          file.path(getwd(), "DNA_tree")
        }
        dir.create(output_dir, showWarnings = FALSE, recursive = TRUE)

        incProgress(0.4, detail = "Running phylogenetic analysis")
                
                #cat("Running Tree\n", file = log_file)
        tree_result <- run_phylogenetic_analysis(
          input_file = temp_file,
          output_dir = output_dir,
          seq_type = input$seq_type,
          threads = input$thread_count,
          metadata = search_results()$metadata,
          color_column = input$color_column,
          file_base_name = file_base_name()
        )
        
        incProgress(0.8, detail = "Generating plot")
        
        output$dynamic_tree_output <- renderUI({
          plotlyOutput("gene_tree_plot_interactive")
        })
        
        output$gene_tree_plot_interactive <- renderPlotly({
          tree_result$plot$interactive
        })
        
        output$gene_tree_info <- renderText({
          paste("Tree successfully generated. Number of tips:", length(tree_result$tree$tip.label))
        })
        output$file_info <- renderText({
          paste("Created files:",
                paste("- Aligned file:", normalizePath(tree_result$created_files$aligned_file)),
                paste("- Tree file:", normalizePath(tree_result$created_files$tree_file)),
                paste("- Plot file:", normalizePath(tree_result$created_files$plot_file)),
                paste("- Interactive plot file:", normalizePath(tree_result$created_files$interactive_plot_file)),
                sep = "\n")
        })

      }, error = function(e) {
        output$gene_tree_info <- renderText({
   error_message <- paste("Error in tree generation:", e$message)

        })
      })
    })
  })

#draw tree
##################



# use shinyjs to load html 
#observe({
#  html_content <- readLines("www/pcoa_plot_interactive.html", warn = FALSE)
#  shinyjs::html("pcoa_container", paste(html_content, collapse = "\n"))
#})

}

options(shiny.useragg = TRUE)

addResourcePath('www', 'www')

# Shiny 앱 실행
shinyApp(ui = ui, server = server, options = list(host = "0.0.0.0", port =7775, static_path = "www") )